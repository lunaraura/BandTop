const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const imgCat = new Image();
imgCat.src = "cat.jpg";   

const backgroundSettings = {
  hills: {
    enabled: true,
    frequency: 0.03,
    color: '#1b6952',
    hillAmplitudes: [200, 100, 50],
    panSpeed: 0.02,
    visible: [],
    visibility: {high: 0.9, low: 0.4, direction: 'down'},
    z: 1
  },
  stars: {
    enabled: true,
    frequency: 0.002,
    color: '#ffffff',
    panSpeed: 0.01,
    visible: [],
    visibility: {high: 0.5, low: 0, direction: 'up'},
    z: 0.5
  },
  trees: {
    enabled: true,
    frequency: 0.005,
    color: '#2e8b57',
    panSpeed: 0.03,
    visible: [],
    visibility: {high: 0.7, low: 0.3, direction: "z"},
    z: 1.5
  },
  mountains: {
    enabled: true,
    frequency: 0.01,
    color: '#654321',
    panSpeed: 0.015,
    visible: [],
    visibility: {high: 0.8, low: 0.5, direction: 'down'},
    z: 1.2
  }
}
const genedBlockDefinitions = {
  0: { name: "empty", color: "#000000", colorVariation: { r: 0, g: 0, b: 0 } },
  1: { name: "grass", color: "#00cc00", colorVariation: { r: 30, g: 30, b: 30 } },
  2: { name: "dirt",  color: "#964B00", colorVariation: { r: 30, g: 30, b: 30 } },
  3: { name: "stone", color: "#888888", colorVariation: { r: 20, g: 20, b: 20 } },
}
const floraBlockDefinitions = {
  4: { name: "treeTrunk", color: "#8B4513", colorVariation: { r: 20, g: 10, b: 5 } },
  5: { name: "treeLeaves", color: "#228B22", colorVariation: { r: 20, g: 30, b: 20 } },
}
const playerBlockDefinitions = {
  6: { name: "table", color: "#c9a26b", colorVariation: { r: 10, g: 10, b: 10 }, space: { nx: 1, px: 1, ny: 0, py: 2 } },
  7: { name: "heart", color: "#ff66aa", colorVariation: { r: 10, g: 10, b: 10 }, space: { nx: 0, px: 0, ny: 0, py: 0 } },
};
const globalBlockPointers = {
  ...genedBlockDefinitions,
  ...floraBlockDefinitions,
  ...playerBlockDefinitions
}

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();
function hexToRgb(hex) {
  const h = hex.startsWith("#") ? hex.slice(1) : hex;
  return {
    r: parseInt(h.slice(0, 2), 16),
    g: parseInt(h.slice(2, 4), 16),
    b: parseInt(h.slice(4, 6), 16),
  };
}
function clampByte(n) {
  return Math.max(0, Math.min(255, n | 0));
}
function hash2i(x, y, seed = 1337) {
  let h = (x * 374761393) ^ (y * 668265263) ^ (seed * 1442695041);
  h = (h ^ (h >>> 13)) * 1274126177;
  return (h ^ (h >>> 16)) >>> 0;
}
function noise2D(x, y) {
  const s = Math.sin(x * 127.1 + y * 311.7) * 43758.5453;
  return (s - Math.floor(s)) * 2 - 1;
}
function lerp(a,b,t){ return a + (b-a)*t; }
function fade(t){ return t*t*(3-2*t); }
function noise1D(x, seed=1234){
  const x0 = Math.floor(x);
  const x1 = x0 + 1;
  const t = fade(x - x0);
  const v0 = ((hash2i(x0, 0, seed) & 0xffff) / 65536) * 2 - 1;
  const v1 = ((hash2i(x1, 0, seed) & 0xffff) / 65536) * 2 - 1;
  return lerp(v0, v1, t);
}
function worldToTile(wx, wy) {
  return { tx: Math.floor(wx / blockSize), ty: Math.floor(wy / blockSize) };
}
function tileToChunk(tx, ty) {
  return { cx: Math.floor(tx / chunkSize), cy: Math.floor(ty / chunkSize) };
}
function localInChunk(tx, ty, cx, cy) {
  return { lx: tx - cx * chunkSize, ly: ty - cy * chunkSize };
}
function tileColor(type, tx, ty) {
  const def = globalBlockPointers[type] || genedBlockDefinitions[0];
  if (!def || !def.color) return "rgba(0,0,0,0)";
  const base = hexToRgb(def.color);
  const v = def.colorVariation || { r: 0, g: 0, b: 0 };
  const h = hash2i(tx, ty, 9001);
  const u1 = (h & 0xffff) / 65536;
  const u2 = ((h >>> 16) & 0xffff) / 65536;
  const r = clampByte(base.r + (u1 - 0.5) * v.r);
  const g = clampByte(base.g + (u2 - 0.5) * v.g);
  const b = clampByte(base.b + (((u1 + u2) * 0.5) - 0.5) * v.b);
  return `rgb(${r},${g},${b})`;
}
function clamp01(t){ return Math.max(0, Math.min(1, t)); }
function easeOutCubic(t){ t = clamp01(t); return 1 - Math.pow(1 - t, 3); }
function easeInOutCubic(t){
  t = clamp01(t);
  return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;
}

//

class SceneManager {
  constructor(defs, startId, player) {
    this.defs = defs;
    this.id = null;
    this.scene = null;
    this.t = 0;
    this.state = {};
    this._events = [];
    this.player = player;
    this.entities = new Set();
    this.clickables = new Set();
    this.set(startId);
    this.drawer = new Drawer(player.camera, canvas, this);
  }
  set(id, payload = {}) {
    if (this.scene?.onExit) this.scene.onExit(this, payload);
    this.id = id;
    this.scene = this.defs[id];
    this.t = 0;
    this.state = {};
    this._events = [];
    if (!this.scene) throw new Error(`Unknown scene: ${id}`);
    if (this.scene.onEnter) this.scene.onEnter(this, this.player, payload);
  }
  at(timeSec, fn) {
    this._events.push({ t: timeSec, fn, fired: false });
    this._events.sort((a,b)=>a.t-b.t);
  }
  update(dt) {
    this.t += dt;
    for (const ev of this._events) {
      if (!ev.fired && this.t >= ev.t) {
        ev.fired = true;
        ev.fn(this);
      }
    }
    if (this.scene?.update) this.scene.update(this, dt);
  }
  drawWorld(ctx, camera) {  
    if (this.scene?.drawWorld) this.scene.drawWorld(this, ctx, camera);
  }
  drawOverlay(ctx) {
    if (this.scene?.drawOverlay) this.scene.drawOverlay(this, ctx);
  }
  reloadClickables() {
    this.clickables.clear();
    if (this.scene?.addClickables) this.scene.addClickables(this);
  }
  goto(id, payload) { this.set(id, payload); }

}
class World {
    constructor() {
        this.chunks = new Map();
        this.visibleChunks = [];
        this.camPosition = { x: 0, y: 0 };
    }
    cameraVisibleChunks(camera) {
        const currentlyVisible = new Set(this.visibleChunks.map(c => `${c.cx},${c.cy}`));
        const visible = [];
        const minCX = Math.floor(camera.x / (chunkSize * blockSize)) - 1;
        const minCY = Math.floor(camera.y / (chunkSize * blockSize)) - 1;
        const maxCX = Math.floor((camera.x + canvas.width) / (chunkSize * blockSize)) + 1;
        const maxCY = Math.floor((camera.y + canvas.height) / (chunkSize * blockSize)) + 1;
        //offload chunks that are no longer visible
        for (const key of currentlyVisible) {
            const [cx, cy] = key.split(",").map(Number);
            if (cx < minCX || cx > maxCX || cy < minCY || cy > maxCY) {
                this.visibleChunks = this.visibleChunks.filter(c => c.cx !== cx || c.cy !== cy);
            }
        }
        //load new visible chunks
        for (let cy = minCY; cy <= maxCY; cy++) {
            for (let cx = minCX; cx <= maxCX; cx++) {
                const key = `${cx},${cy}`;
                if (this.chunks.has(key)) visible.push(this.chunks.get(key));
                else {
                    const chunk = new Chunk(cx, cy);
                    this.chunks.set(key, chunk);
                    visible.push(chunk);
                }
            }
        }
    }
    getChunk(cx, cy) {
        const key = `${cx},${cy}`;
        if (!this.chunks.has(key)) this.chunks.set(key, new Chunk(cx, cy));
        return this.chunks.get(key);
    }
    checkChunkKey(cx, cy) {
        return this.chunks.has(`${cx},${cy}`);
    }
    createOrLoadChunk(cx, cy) {
        const key = `${cx},${cy}`;
        if (!this.chunks.has(key)) {
            const chunk = new Chunk(cx, cy);
            this.chunks.set(key, chunk);
            return chunk;
        }
        return this.chunks.get(key);
    }   
    offloadChunks(camera) {
        const minCX = Math.floor(camera.x / (chunkSize * blockSize)) - 2;
        const minCY = Math.floor(camera.y / (chunkSize * blockSize)) - 2;
        const maxCX = Math.floor((camera.x + canvas.width) / (chunkSize * blockSize)) + 2;
        const maxCY = Math.floor((camera.y + canvas.height) / (chunkSize * blockSize)) + 2;
        for (const key of this.chunks.keys()) {
            const [cx, cy] = key.split(",").map(Number);
            if (cx < minCX || cx > maxCX || cy < minCY || cy > maxCY) {
                this.visibleChunks = this.visibleChunks.filter(c => c.cx !== cx || c.cy !== cy);
            }
        }
    }
}
class Chunk {
    constructor(cx, cy) {
        this.cx = cx;
        this.cy = cy;
        this.blocks = new Map();
        this.floraViable = [];
        this.floraEntities = [];
        this.generateProcedural();
    }
    getBlockAt(wx, wy) {
        const bx = wx - this.cx * chunkSize * blockSize;
        const by = wy - this.cy * chunkSize * blockSize;
        const key = `${bx},${by}`;
        return this.blocks.get(key);
    }
    setBlockAt(wx, wy, type) {
        const bx = wx - this.cx * chunkSize * blockSize;
        const by = wy - this.cy * chunkSize * blockSize;
        const key = `${bx},${by}`;
        if (type === null) this.blocks.delete(key);
        else this.blocks.set(key, { type });
    }
    generateProcedural() {
        const baseSurfaceY = 35;
        const heightVariation = 1;
        const grassThickness = 3;
        const dirtDepth = 8;
        for (let by = 0; by < chunkSize * blockSize; by += blockSize) {
            for (let bx = 0; bx < chunkSize * blockSize; bx += blockSize) {
                const wx = this.cx * chunkSize * blockSize + bx;
                const wy = this.cy * chunkSize * blockSize + by;
                const height = noise2D(wx * 0.001, 0) * 100 + 200;
                const surfaceY = height;
                if (wy > surfaceY && wy <= surfaceY + grassThickness) {
                    this.setBlockAt(wx, wy, 1); // Grass
                    this.floraViable.push({ wx, wy: surfaceY }); // Store the top of the grass for flora placement
                }
                else if (wy > surfaceY + grassThickness && wy <= surfaceY + grassThickness + dirtDepth) {
                    this.setBlockAt(wx, wy, 2); // Dirt
                }
                else if (wy > surfaceY + grassThickness + dirtDepth && wy <= baseSurfaceY + heightVariation) {
                    this.setBlockAt(wx, wy, 3); // Stone
                }
            }
        }
    }
    decorate() {
        for (const spot of this.floraViable) {
            const r = Math.random();
            if (r < 0.05) {
                const flowerType = Math.random() < 0.5 ? "red" : "yellow";
                entities.add(new FlowerEntity(spot.wx, spot.wy, flowerType));
            }
            else if (r < 0.1) {
                entities.add(new TreeEntity(spot.wx, spot.wy));
            }
        }
    }
}
class Entity {
  constructor(wx, wy, clickable, radius = 0) {
    this.wx = wx;
    this.wy = wy;

    this.vx = 0;
    this.vy = 0;
    this.clickable = clickable;
    this.isHeld = false;
    this.radius = radius;
    this.rotation = 0;
    this.scale = 1;
    this.alive = true;
    this.z = 0;
  }
  update(dt) {
    this.wx += this.vx * dt;
    this.wy += this.vy * dt;
  }
  addToClickable(scene) {
    if (this.clickable) {
        scene.clickables.add(this);
    }
  }
  hitTest(wx, wy) {
    const dx = wx - this.wx, dy = wy - this.wy;
    return (dx*dx + dy*dy) <= (this.radius*this.radius);
  }
  draw(ctx, camera) {
  }
}
class Player {
    constructor() {
        this.sm = null;
        this.camera = { x: 0, y: 0 };
        this.mouse = { x: 0, y: 0, down: false };
        this.input = { down: Object.create(null), pressed: Object.create(null), released: Object.create(null) };
        this.vx = 0; this.vy = 0;
        this._bindEvents();

        this.inventory = {
            toolIndex: 0,
            placeIndex: 0,
            flowers: [],
            blocks: new Map(),
        };
        this.tools = new Toolbelt(this);
    }
    _bindEvents() {
        const c = canvas;
        c.addEventListener("mousemove", (e) => {
        const r = c.getBoundingClientRect();
        this.mouse.sx = e.clientX - r.left;
        this.mouse.sy = e.clientY - r.top;
        });
        c.addEventListener("mousedown", () => { this.mouse.down = true; this.mouse.clicked = true; });
        window.addEventListener("mouseup", () => { this.mouse.down = false; });

        window.addEventListener("keydown", (e) => {
        if (!this.input.down[e.key]) this.input.pressed[e.key] = true;
        this.input.down[e.key] = true;
        });
        window.addEventListener("keyup", (e) => {
        this.input.down[e.key] = false;
        this.input.released[e.key] = true;
        });
    }
    beginFrame() {
        this.input.pressed = Object.create(null);
        this.input.released = Object.create(null);
        this.mouse.clicked = false;
    }
    isDown(key) { return !!this.input.down[key]; }
    wasPressed(key) { return !!this.input.pressed[key]; }
    wasReleased(key) { return !!this.input.released[key]; }

    screenToWorld(sx, sy) { return { wx: sx + this.camera.x, wy: sy + this.camera.y }; }
    mouseWorld() { return this.screenToWorld(this.mouse.sx, this.mouse.sy); }
    update(dt) {
        const speed = 300;
        let dx = 0, dy = 0;
        if (this.isDown("ArrowLeft") || this.isDown("a")) dx -= 1;
        if (this.isDown("ArrowRight") || this.isDown("d")) dx += 1;
        if (this.isDown("ArrowUp") || this.isDown("w")) dy -= 1;
        if (this.isDown("ArrowDown") || this.isDown("s")) dy += 1;
        if (dx || dy) { this.camera.x += dx * speed * dt; this.camera.y += dy * speed * dt; }
        if (this.mouse.clicked) this.tools.useCurrentTool(this.sm.scene);
        
    }
    clickedOn(x, y, hitboxSize = 20) {
        const { wx, wy } = this.mouseWorld();
        return Math.abs(wx - x) <= hitboxSize && Math.abs(wy - y) <= hitboxSize;
    }
    invGet(type){ return this.inventory.blocks.get(type) ?? 0; }
    invAdd(type, n=1){ this.inventory.blocks.set(type, this.invGet(type) + n); }
    invSpend(type, n=1){
        const have = this.invGet(type);
        if (have < n) return false;
        this.inventory.blocks.set(type, have - n);
        return true;
    }
}
class Toolbelt {
    constructor(player) {
        this.player = player;
        this.toolIndex = 0;
        this.blockIndex = 0;
        this.tools = {
            0: { name: "Hand", action: (scene) => {
                const { wx, wy } = this.player.mouseWorld();
                for (const ent of scene.clickables) {
                    if (ent.hitTest(wx, wy)) {
                        if (ent.onClick) ent.onClick(scene, this.player);
                        break;
                    }
                }
             }},
            1: { name: "Shovel", action: (scene) => {
                const { wx, wy } = this.player.mouseWorld();
                const block = scene.getBlockAt(wx, wy);
                if (block) {
                    scene.removeBlockAt(wx, wy);
                    this.player.invAdd(block.type);
                }
            }},
            2: { name: "Placer", action: (scene) => {
                const { wx, wy } = this.player.mouseWorld();
                const blockType = this.player.inventory.placeIndex;
                if (this.player.invGet(blockType) > 0) {
                    scene.placeBlockAt(wx, wy, blockType);
                    this.player.invSpend(blockType);
                }
            }},
            3: { name: "FlowerPicker", action: (scene) => {
                const { wx, wy } = this.player.mouseWorld();
                for (const ent of scene.clickables) {
                    if (ent.hitTest(wx, wy) && ent instanceof FlowerEntity) {
                        this.player.inventory.flowers.push(ent.flowerType);
                        ent.alive = false;
                        break;
                    }
                }
            }},
            4: { name: "HeartWand", action: (scene) => {
                const { wx, wy } = this.player.mouseWorld();
                const heart = new HeartEntity(wx, wy);
                scene.addEntity(heart);
                }
            }
        }
    }
    currentTool() { return this.tools[this.toolIndex]; }
    useCurrentTool(scene) {
        const tool = this.currentTool();
        if (tool && tool.action) tool.action(scene);
    }
}
class Drawer {
    constructor(camera, canvas, scene) {
        this.camera = camera;
        this.canvas = canvas;
        this.scene = scene;
        this.backgroundData = {};
        thi
    }
    initBackground() {
    }
    drawBackground() {
    }
    drawVisibleChunk(cx,cy) {
    }
    drawEntity(ent) {
    }
    drawHUD() {
    }
    drawTile(type, sx, sy) {
    }
    worldToScreen(wx, wy) {
        return { sx: wx - this.camera.x, sy: wy - this.camera.y };
    }
}


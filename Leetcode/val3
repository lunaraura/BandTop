const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const imgCat = new Image();
imgCat.src = "cat.jpg";

const blockSize = 10;
const chunkSize = 16;

const backgroundSettings = {
  hills: { enabled: true, frequency: 0.03, colors: {midnight: "#1b6952", noon: "#87ceeb"}, hillAmplitudes: [200, 100, 50], panSpeed: 0.02 },
  stars: { enabled: true, frequency: 0.002, colors: {midnight: "#ffffff", noon: "#aaf2ff"}, panSpeed: 0.01 },
  trees: { enabled: true, frequency: 0.005, colors: {midnight: "#2e8b57", noon: "#66cdaa"}, panSpeed: 0.03 },
  mountains: { enabled: true, frequency: 0.01, colors: {midnight: "#302011", noon: "#a0522d"}, panSpeed: 0.015 }
};

const genedBlockDefinitions = {
  0: { name: "empty", color: "#000000", colorVariation: { r: 0, g: 0, b: 0 } },
  1: { name: "grass", color: "#00cc00", colorVariation: { r: 30, g: 30, b: 30 } },
  2: { name: "dirt", color: "#964B00", colorVariation: { r: 30, g: 30, b: 30 } },
  3: { name: "stone", color: "#888888", colorVariation: { r: 20, g: 20, b: 20 } }
};
const floraBlockDefinitions = {
  4: { name: "treeTrunk", color: "#8B4513", colorVariation: { r: 20, g: 10, b: 5 } },
  5: { name: "treeLeaves", color: "#228B22", colorVariation: { r: 20, g: 30, b: 20 } }
};
const playerBlockDefinitions = {
  6: { name: "table", color: "#c9a26b", colorVariation: { r: 10, g: 10, b: 10 } },
  7: { name: "heart", color: "#ff66aa", colorVariation: { r: 10, g: 10, b: 10 } }
};
const globalBlockPointers = { ...genedBlockDefinitions, ...floraBlockDefinitions, ...playerBlockDefinitions };

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// ----------------- utils -----------------
function hexToRgb(hex) {
  const h = hex.startsWith("#") ? hex.slice(1) : hex;
  return { r: parseInt(h.slice(0, 2), 16), g: parseInt(h.slice(2, 4), 16), b: parseInt(h.slice(4, 6), 16) };
}
function clampByte(n) { return Math.max(0, Math.min(255, n | 0)); }
function hash2i(x, y, seed = 1337) {
  let h = (x * 374761393) ^ (y * 668265263) ^ (seed * 1442695041);
  h = (h ^ (h >>> 13)) * 1274126177;
  return (h ^ (h >>> 16)) >>> 0;
}
function noise2D(x, y) {
  const s = Math.sin(x * 127.1 + y * 311.7) * 43758.5453;
  return (s - Math.floor(s)) * 2 - 1;
}
function lerp(a, b, t) { return a + (b - a) * t; }
function fade(t) { return t * t * (3 - 2 * t); }
function noise1D(x, seed = 1234) {
  const x0 = Math.floor(x);
  const x1 = x0 + 1;
  const t = fade(x - x0);
  const v0 = ((hash2i(x0, 0, seed) & 0xffff) / 65536) * 2 - 1;
  const v1 = ((hash2i(x1, 0, seed) & 0xffff) / 65536) * 2 - 1;
  return lerp(v0, v1, t);
}
function tileColor(type, tx, ty) {
  const def = globalBlockPointers[type] || genedBlockDefinitions[0];
  if (!def || !def.color) return "rgba(0,0,0,0)";
  const base = hexToRgb(def.color);
  const v = def.colorVariation || { r: 0, g: 0, b: 0 };
  const h = hash2i(tx, ty, 9001);
  const u1 = (h & 0xffff) / 65536;
  const u2 = ((h >>> 16) & 0xffff) / 65536;
  const r = clampByte(base.r + (u1 - 0.5) * v.r);
  const g = clampByte(base.g + (u2 - 0.5) * v.g);
  const b = clampByte(base.b + (((u1 + u2) * 0.5) - 0.5) * v.b);
  return `rgb(${r},${g},${b})`;
}
const v2 = {
    add: (a, b) => ({ x: a.x + b.x, y: a.y + b.y }),
    mul: (v, s) => ({ x: v.x * s, y: v.y * s }),
};
function snapToBlock(wx) { return Math.floor(wx / blockSize) * blockSize; }
function snapToGrid(wx, wy) {
  return { wx: Math.floor(wx / blockSize) * blockSize, wy: Math.floor(wy / blockSize) * blockSize };
}

// ----------------- scene manager -----------------
class SceneManager {
  constructor(defs, startId, player) {
    this.defs = defs;
    this.id = null;
    this.scene = null;
    this.t = 0;
    this.state = {};
    this._events = [];
    this.player = player;

    this.entities = new Set();
    this.clickables = new Set();

    this.set(startId);
    this.drawer = new Drawer(player.camera, canvas, this);
  }

  set(id, payload = {}) {
    if (this.scene?.onExit) this.scene.onExit(this, payload);
    this.id = id;
    this.scene = this.defs[id];
    this.t = 0;
    this.state = {};
    this._events = [];
    if (!this.scene) throw new Error(`Unknown scene: ${id}`);
    if (this.scene.onEnter) this.scene.onEnter(this, this.player, payload);
    this.reloadClickables();
  }

  at(timeSec, fn) {
    this._events.push({ t: timeSec, fn, fired: false });
    this._events.sort((a, b) => a.t - b.t);
  }

  update(dt) {
    this.t += dt;
    for (const ev of this._events) {
      if (!ev.fired && this.t >= ev.t) {
        ev.fired = true;
        ev.fn(this);
      }
    }
    if (this.scene?.update) this.scene.update(this, dt);
  }

  drawWorld(ctx, camera) {
    if (this.scene?.drawWorld) this.scene.drawWorld(this, ctx, camera);
  }
  drawOverlay(ctx) {
    if (this.scene?.drawOverlay) this.scene.drawOverlay(this, ctx);
  }

  reloadClickables() {
    this.clickables.clear();
    // entities that mark themselves clickable
    for (const e of this.entities) e.addToClickable?.(this);
    // plus any scene-specified clickables
    if (this.scene?.addClickables) this.scene.addClickables(this);
  }

  goto(id, payload) { this.set(id, payload); }
}

// ----------------- world/chunks -----------------
class World {
  constructor() {
    this.chunks = new Map();          // key -> Chunk
    this.visibleChunks = [];          // array<Chunk>
  }

  key(cx, cy) { return `${cx},${cy}`; }

  getChunk(cx, cy) {
    const k = this.key(cx, cy);
    if (!this.chunks.has(k)) this.chunks.set(k, new Chunk(cx, cy));
    return this.chunks.get(k);
  }

  worldToChunk(wx, wy) {
    const cx = Math.floor(wx / (chunkSize * blockSize));
    const cy = Math.floor(wy / (chunkSize * blockSize));
    return { cx, cy };
  }

  // keep a window of chunks around camera viewport
  updateVisible(camera) {
    const minCX = Math.floor(camera.x / (chunkSize * blockSize)) - 1;
    const minCY = Math.floor(camera.y / (chunkSize * blockSize)) - 1;
    const maxCX = Math.floor((camera.x + canvas.width) / (chunkSize * blockSize)) + 1;
    const maxCY = Math.floor((camera.y + canvas.height) / (chunkSize * blockSize)) + 1;

    const visible = [];
    for (let cy = minCY; cy <= maxCY; cy++) {
      for (let cx = minCX; cx <= maxCX; cx++) {
        const ch = this.getChunk(cx, cy);
        if (!ch._decorated) { ch.decorate(); ch._decorated = true; }
        visible.push(ch);
      }
    }
    this.visibleChunks = visible;

    // optional offload: not needed for basics; keep it simple
  }

  getBlockAt(wx, wy) {
    const { cx, cy } = this.worldToChunk(wx, wy);
    return this.getChunk(cx, cy).getBlockAt(wx, wy);
  }
  setBlockAt(wx, wy, type) {
    const { cx, cy } = this.worldToChunk(wx, wy);
    this.getChunk(cx, cy).setBlockAt(wx, wy, type);
  }
  removeBlockAt(wx, wy) {
    const { cx, cy } = this.worldToChunk(wx, wy);
    this.getChunk(cx, cy).setBlockAt(wx, wy, null);
  }
}

class Chunk {
  constructor(cx, cy) {
    this.cx = cx;
    this.cy = cy;
    this.blocks = new Map(); // "bx,by" -> {type}
    this.floraViable = [];
    this._decorated = false;
    this.generateProcedural();
  }

  // store blocks snapped to world-grid
  _key(wx, wy) {
    const bx = snapToBlock(wx) - this.cx * chunkSize * blockSize;
    const by = snapToBlock(wy) - this.cy * chunkSize * blockSize;
    return `${bx},${by}`;
  }

  getBlockAt(wx, wy) {
    const key = this._key(wx, wy);
    return this.blocks.get(key) ?? null;
  }

  setBlockAt(wx, wy, type) {
    const key = this._key(wx, wy);
    if (type == null || type === 0) this.blocks.delete(key);
    else this.blocks.set(key, { type });
  }

  generateProcedural() {
    const worldX0 = this.cx * chunkSize * blockSize;
    const worldY0 = this.cy * chunkSize * blockSize;

    const grassThicknessPx = 4 * blockSize;
    const dirtDepthPx = 12 * blockSize;
    const start = Math.round(canvas.height/1.5)
    for (let by = 0; by < chunkSize * blockSize; by += blockSize) {
      for (let bx = 0; bx < chunkSize * blockSize; bx += blockSize) {
        const wx = worldX0 + bx;
        const wy = worldY0 + by;
        const surface = start + noise2D(wx * 0.0025, 0.5) * 15;
        const top = surface;

        if (wy >= top && wy < top + grassThicknessPx) {
          this.setBlockAt(wx, wy, 1);
          if (wy === Math.floor(top / blockSize) * blockSize) this.floraViable.push({ wx, wy });
        } else if (wy >= top + grassThicknessPx && wy < top + grassThicknessPx + dirtDepthPx) {
          this.setBlockAt(wx, wy, 2);
        } else if (wy >= top + grassThicknessPx + dirtDepthPx) {
          this.setBlockAt(wx, wy, 3);
        }
      }
    }
  }
  decorate() {
  }
}

// ----------------- entities -----------------
class Entity {
  constructor(wx, wy, clickable = false, radius = 0) {
    this.wx = wx;
    this.wy = wy;
    this.vx = 0;
    this.vy = 0;
    this.clickable = clickable;
    this.radius = radius;
    this.alive = true;
    this.z = 0;
  }
  update(dt) { this.wx += this.vx * dt; this.wy += this.vy * dt; }
  addToClickable(scene) { if (this.clickable) scene.clickables.add(this); }
  hitTest(wx, wy) {
    const dx = wx - this.wx, dy = wy - this.wy;
    return (dx * dx + dy * dy) <= (this.radius * this.radius);
  }
  interaction(scene, player) {} //for subclasses to override
  draw(ctx, camera) {
    const sx = this.wx - camera.x;
    const sy = this.wy - camera.y;
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.7)";
    ctx.beginPath();
    ctx.arc(sx, sy, Math.max(3, this.radius || 6), 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}
class FloatingHeart extends Entity {
  constructor(wx, wy, opts = {}) {
    super(wx, wy, opts.clickable ?? true, opts.radius ?? 18);
    this.vx = opts.vx ?? 0;
    this.vy = opts.vy ?? -20;
    this.life = opts.life ?? 2.0;
    this.interaction = opts.interaction ?? "none";
    this.radius = opts.radius ?? 18; 
    this.dragStrength = opts.dragStrength ?? 14;
    this.attractStrength = opts.attractStrength ?? 6;

    this._held = false;
    this._holdDx = 0;
    this._holdDy = 0;
  }

  hitTest(wx, wy) {
    const dx = wx - this.wx, dy = wy - this.wy;
    return (dx*dx + dy*dy) <= (this.radius*this.radius);
  }
  update(dt) {
    if (this.life !== Infinity) {
      this.life -= dt;
      if (this.life <= 0) { this.alive = false; return; }
    }

    this.wx += this.vx * dt;
    this.wy += this.vy * dt;
    this.vx *= 0.97;
    this.vy *= 0.97;

    const t = (this.life === Infinity) ? 1 : Math.max(0, Math.min(1, this.life / 2.0));
    this.scale = 1 + t * 0.5;
  }

  draw(ctx, camera) {
    const x = this.wx - camera.x;
    const y = this.wy - camera.y;

    ctx.save();
    ctx.translate(x, y);
    ctx.scale(this.scale, this.scale);

    ctx.fillStyle = "pink";
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.bezierCurveTo(-5, -5, -10, 5, 0, 10);
    ctx.bezierCurveTo(10, 5, 5, -5, 0, 0);
    ctx.fill();

    ctx.restore();
  }
}
class HeartEntity extends Entity {
  constructor(wx, wy, solid = false) {
    super(wx, wy, false, 10);
    this.vy = -60;
    this.solid = solid;
    this.init()
    this.life = 1000;
  }
  init() {
    if (!this.solid) {
        this.life = 1.8;
        this.clickable = false;
    } else {
        this.life = 1000;
        this.clickable = true;
    }
  }
  update(dt) {
    this.life -= dt;
    if (this.life <= 0) { this.alive = false; return; }
    this.vy += 140 * dt;
    this.wx += this.vx * dt;
    this.wy += this.vy * dt;
    this.hitsGround(300);
  }
  hitsGround(groundY) {
    if (this.wy >= groundY) {
        this.life = 0;
    }
  }
  draw(ctx, camera) {
    const x = this.wx - camera.x;
    const y = this.wy - camera.y;
    ctx.save();
    ctx.globalAlpha = Math.max(0, Math.min(1, this.life / 1.8));
    ctx.fillStyle = "pink";
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.bezierCurveTo(x - 6, y - 6, x - 12, y + 4, x, y + 12);
    ctx.bezierCurveTo(x + 12, y + 4, x + 6, y - 6, x, y);
    ctx.fill();
    ctx.restore();
  }
}
class FlowerEntity extends Entity {
  constructor(tx, ty) {
    const wx = tx * blockSize + blockSize / 2;
    const wy = ty * blockSize + blockSize / 2;
    super(wx, wy, true, 8);
    this.tx = tx; this.ty = ty;
    this.z = 5;
        this.seed = hash2i(tx, ty, 4242);
    this.petalCount = this.randomRange(
      flowerLimits.petalCount.min,
      flowerLimits.petalCount.max
    );
    this.leafCount = this.randomRange(
      flowerLimits.leafCount.min,
      flowerLimits.leafCount.max
    );
    this.petalShapeId = this.pickKey(petalShapes);
    this.leafShapeId  = this.pickKey(leafShapes);

    this.stemHeight = this.randomRange(
      flowerLimits.stemHeight.min,
      flowerLimits.stemHeight.max
    );

    this.petalShape = this.pickFrom(petalShapes);
    this.leafShape = this.pickFrom(leafShapes);

    this.color = this.randomColor();
  }
  rand() {
    this.seed ^= this.seed << 13;
    this.seed ^= this.seed >> 17;
    this.seed ^= this.seed << 5;
    return (this.seed >>> 0) / 4294967295;
  }
  randomRange(min, max) {
    return Math.floor(this.rand() * (max - min + 1)) + min;
  }
  pickFrom(obj) {
    const keys = Object.keys(obj);
    return obj[keys[Math.floor(this.rand() * keys.length)]];
  }
  randomColor() {
    const r = 150 + Math.floor(this.rand() * 100);
    const g = 50 + Math.floor(this.rand() * 150);
    const b = 150 + Math.floor(this.rand() * 100);
    return `rgb(${r},${g},${b})`;
  }
    draw(ctx, camera) {
    const screenX = this.wx - camera.x;
    const screenY = this.wy - camera.y;
    ctx.save();

    ctx.strokeStyle = "#2e8b57";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(screenX, screenY);
    ctx.lineTo(screenX, screenY - this.stemHeight * blockSize);
    ctx.stroke();

    ctx.fillStyle = this.color;

    const flowerTopY = screenY - this.stemHeight * blockSize;
    const radius = blockSize * 0.6;

    for (let i = 0; i < this.petalCount; i++) {
      const angle = (Math.PI * 2 * i) / this.petalCount;
      const px = screenX + Math.cos(angle) * radius;
      const py = flowerTopY + Math.sin(angle) * radius;

      ctx.beginPath();
      ctx.arc(px, py, blockSize * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.fillStyle = "#ffd700";
    ctx.beginPath();
    ctx.arc(screenX, flowerTopY, blockSize * 0.25, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }
  exportDrawData() {
    return {
      type: "flower",
      tx: this.tx,
      ty: this.ty,
      petalCount: this.petalCount,
      leafCount: this.leafCount,
      stemHeight: this.stemHeight,
      petalShapeId: this.petalShapeId,
      leafShapeId: this.leafShapeId,
      color: this.color
    };
  }
  interaction(scene, player) {
    if (player.tools.isCurrentTool("Hand")){
        //pick flower
        player.invAdd(4, 1);
        scene.entities.delete(this);
    } else if (player.tools.isCurrentTool("HeartWand")){
        //multiple hearts spawn outwards
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI * 2 * i) / 6;
            const vx = Math.cos(angle) * 50;
            const vy = Math.sin(angle) * 50;
            const heart = new HeartEntity(this.wx, this.wy);
            const extraHeart = new FloatingHeart(this.wx, this.wy, { vx, vy, life: 2.8 + Math.random() * 1.2 })
            heart.vx = vx;
            heart.vy = vy;
            extraHeart.vx = -vx;
            extraHeart.vy = -vy;
            scene.entities.add(heart);
        }
    }
  }
  pickKey(obj) {
    const keys = Object.keys(obj);
    return keys[Math.floor(this.rand() * keys.length)];
  }
}

class BigFlower extends Entity {
  constructor(wx, wy, seed = 91234) {
    super(wx, wy, true, 20);
    this.z = 5;
    this.seed = seed >>> 0;
    
    this.nodes = [];
    this.attachments = [];

    this.grow = 0;
    this.growRate = 0.35;
    this.delay = 0;

    // explode state
    this.mode = "growing";      // "growing" | "blossom" | "exploding"
    this.explodeT = 0;          // seconds since explosion
    this.explodeDur = 0.9;      // stems retract over this time
    this.noAttachAfterExplode = true;

    // tuning
    this.maxDepth = 2;
    this.maxSegmentsPerBranch = 5;
    this.baseLen = 3;
    this.lenJitter = 0.25;
    this.branchProb = 0.35;
    this.branchSpread = Math.PI * 0.35;
    this.trunkUpAngle = -Math.PI / 2;

    this.generate();
  }
  rand() {
    let s = this.seed | 0;
    s ^= s << 13;
    s ^= s >>> 17;
    s ^= s << 5;
    this.seed = s >>> 0;
    return (this.seed >>> 0) / 4294967295;
  }
  rrange(a, b) { return a + (b - a) * this.rand(); }
  rint(a, b) { return Math.floor(this.rrange(a, b + 1)); }

  generate() {
    this.nodes.length = 0;
    this.attachments.length = 0;

    const root = this.addNode(this.wx, this.wy, 6, -1);
    this.growBranch(root, this.trunkUpAngle, 0);
  }
  addNode(x, y, r, parent) {
    const idx = this.nodes.length;
    this.nodes.push({ x, y, r, parent });
    return idx;
  }
  
  growBranch(parentIdx, parentAngle, depth) {
    let current = parentIdx;
    let angle = parentAngle;

    const segCount = this.rint(5, this.maxSegmentsPerBranch);
    for (let i = 0; i < segCount; i++) {
      angle += this.rrange(-0.12, 0.12);

      const len = this.baseLen * this.rrange(1 - this.lenJitter, 1 + this.lenJitter);
      const dir = { x: Math.cos(angle), y: Math.sin(angle) };

      const from = this.nodes[current];
      const toPos = v2.add(from, v2.mul(dir, len));

      const taper = 1 - (depth * 0.18) - (i / segCount) * 0.35;
      const radius = Math.max(1.5, from.r * taper);

      const next = this.addNode(toPos.x, toPos.y, radius, current);

      if (depth >= 1 && i > 1 && this.rand() < 0.35) {
        const leafAngle = angle + (this.rand() < 0.5 ? -1 : 1) * this.rrange(0.6, 1.2);
        this.attachments.push({
          kind: "leaf",
          node: next,
          angle: leafAngle,
          size: this.rrange(10, 22) * (1 - depth * 0.12),
          color: "#2e8b57",
        });
      }

      if (depth < this.maxDepth && i > 1 && this.rand() < this.branchProb) {
        const sideCount = this.rint(1, 2);
        for (let s = 0; s < sideCount; s++) {
          const sideAngle = angle + this.rrange(-this.branchSpread, this.branchSpread);
          this.growBranch(next, sideAngle, depth + 1);
        }
      }

      current = next;
    }

    this.attachments.push({
      kind: "bud",
      node: current,
      angle,
      size: this.rrange(10, 18) * (1 - depth * 0.08),
      color: "#ffd700",
    });

    if (this.rand() < 0.85) {
      this.attachments.push({
        kind: "petals",
        node: current,
        angle,
        size: this.rrange(16, 26) * (1 - depth * 0.08),
        color: `rgb(${150 + this.rint(0,100)},${50 + this.rint(0,150)},${150 + this.rint(0,100)})`,
      });
    }
  }
  _currentTipNodeIndex() {
    const segCountTotal = Math.max(0, this.nodes.length - 1);
    const segsToDraw = Math.min(segCountTotal, Math.floor(this.grow * segCountTotal));
    return Math.max(0, segsToDraw);
  }
  update(dt) {
    if (this.delay > 0) { this.delay -= dt; return; }
    if (this.grow >= 1 && this.mode === "growing") {
      this.mode = "blossom";
    }
    if (this.mode === "growing") {
      this.grow = Math.min(1, this.grow + this.growRate * dt);
    } else if (this.mode === "exploding") {
      this.explodeT += dt;
      if (this.explodeT >= this.explodeDur) {
        this.alive = false;
      }
    }
  }
  interaction(scene, player) {
    if (player.tools.isCurrentTool("Hand") && this.mode === "growing") return; //cant explode while growing
    if (player.tools.isCurrentTool("Hand") && this.mode === "blossom") { //can explode when fully bloomed
        this.mode = "exploding";
        this.explodeT = 0;
        return;
    }
    if (player.tools.isCurrentTool("HeartWand") && this.mode !== "exploding") {
        this.mode = "exploding";
        this.explodeT = 0;
        const tipIdx = this._currentTipNodeIndex();
        for (let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 * i) / 8;
            const vx = Math.cos(angle) * 80;
            const vy = Math.sin(angle) * 80;
            const heart = new HeartEntity(this.nodes[tipIdx].x, this.nodes[tipIdx].y);
            
            heart.vx = vx;
            heart.vy = vy;
            scene.entities.add(heart);
        }
    }
  }
  draw(ctx, camera) {
    ctx.save();
    ctx.lineCap = "round";
    ctx.strokeStyle = "#2e8b57";

    const segCountTotal = Math.max(0, this.nodes.length - 1);

    // when exploding, retract from current grown amount down to 0
    let segsToDraw = Math.min(segCountTotal, Math.floor(this.grow * segCountTotal));
    if (this.mode === "exploding") {
      const t = Math.min(1, this.explodeT / this.explodeDur);
      segsToDraw = Math.floor(segsToDraw * (1 - t));
      ctx.globalAlpha = 1 - t * 0.9;
    }

    // stems
    for (let i = 1; i <= segsToDraw; i++) {
      const n = this.nodes[i];
      const p = this.nodes[n.parent];
      const x1 = p.x - camera.x, y1 = p.y - camera.y;
      const x2 = n.x - camera.x, y2 = n.y - camera.y;

      ctx.lineWidth = Math.max(1, n.r * 0.6);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    // attachments only when not exploding
    if (this.mode === "growing") {
      const aT = Math.max(0, (this.grow - 0.6) / 0.4);
      if (aT > 0) {
        ctx.globalAlpha = aT;

        for (const a of this.attachments) {
          if (a.node > segsToDraw) continue;

          const n = this.nodes[a.node];
          const x = n.x - camera.x;
          const y = n.y - camera.y;

          if (a.kind === "leaf") {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(a.angle);
            ctx.fillStyle = a.color;
            ctx.beginPath();
            ctx.ellipse(0, 0, a.size * 0.9, a.size * 0.45, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          } else if (a.kind === "bud") {
            ctx.fillStyle = a.color;
            ctx.beginPath();
            ctx.arc(x, y, a.size * 0.25, 0, Math.PI * 2);
            ctx.fill();
          } else if (a.kind === "petals") {
            const count = 6;
            const radius = a.size * 0.55;
            ctx.fillStyle = a.color;
            for (let i = 0; i < count; i++) {
              const ang = (Math.PI * 2 * i) / count;
              const px = x + Math.cos(ang) * radius;
              const py = y + Math.sin(ang) * radius;
              ctx.beginPath();
              ctx.arc(px, py, a.size * 0.18, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }

        ctx.globalAlpha = 1;
      }
    }

    ctx.restore();
  }
}

class FlowerParticle extends Entity {
  constructor(wx, wy, opts = {}) {
    super(wx, wy, false, opts.size ?? 6);
    this.vx = opts.vx ?? 0;
    this.vy = opts.vy ?? -200;
    this.life = opts.life ?? 1.2;
    this.rot = opts.rot ?? 0;
    this.vrot = opts.vrot ?? (Math.random() - 0.5) * 8;
    this.size = opts.size ?? 6;
    this.color = opts.color ?? "pink";
    this.drag = opts.drag ?? 0.9;
    this.gravity = opts.gravity ?? 520;
    this.shape = opts.shape ?? "circle";
  }
  update(dt) {
    this.life -= dt;
    if (this.life <= 0) { this.alive = false; return; }
    this.vy += this.gravity * dt;
    this.wx += this.vx * dt;
    this.wy += this.vy * dt;
    const damp = Math.pow(this.drag, dt * 60);
    this.vx *= damp;
    this.vy *= damp;
    this.rot += this.vrot * dt;
  }
  draw(ctx, camera) {
    const x = this.wx - camera.x;
    const y = this.wy - camera.y;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(this.rot);
    const a = Math.max(0, Math.min(1, this.life / 1.2));
    ctx.globalAlpha = a;
    ctx.fillStyle = this.color;
    if (this.shape === "leaf") {
      ctx.beginPath();
      ctx.ellipse(0, 0, this.size * 0.9, this.size * 0.45, 0, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.beginPath();
      ctx.arc(0, 0, this.size * 0.45, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }
}
class CatFace extends Entity {
  constructor(wx, wy) {
    super(wx, wy);
    this.emoji = "ðŸ˜¼";
  }
}
// ----------------- player/tools -----------------
class Player {
  constructor() {
    this.sm = null;
    this.camera = { x: 0, y: 0 };
    this.mouse = { sx: 0, sy: 0, down: false, clicked: false };
    this.input = { down: Object.create(null), pressed: Object.create(null), released: Object.create(null) };
    this._bindEvents();
    this.inventory = {
      toolIndex: 0,
      placeIndex: 1,
      flowers: [],
      blocks: new Map()
    };
    this.tools = new Toolbelt(this);
    this.holding = [];
  }
  _bindEvents() {
    const c = canvas;
    c.addEventListener("mousemove", (e) => {
      const r = c.getBoundingClientRect();
      this.mouse.sx = e.clientX - r.left;
      this.mouse.sy = e.clientY - r.top;
    });
    c.addEventListener("mousedown", () => { this.mouse.down = true; this.mouse.clicked = true; });
    window.addEventListener("mouseup", () => { this.mouse.down = false; });

    window.addEventListener("keydown", (e) => {
      if (!this.input.down[e.key]) this.input.pressed[e.key] = true;
      this.input.down[e.key] = true;
    });
    window.addEventListener("keyup", (e) => {
      this.input.down[e.key] = false;
      this.input.released[e.key] = true;
    });
  }

  beginFrame() {
    this.input.pressed = Object.create(null);
    this.input.released = Object.create(null);
    this.mouse.clicked = false;
  }

  isDown(key) { return !!this.input.down[key]; }
  wasPressed(key) { return !!this.input.pressed[key]; }

  screenToWorld(sx, sy) { return { wx: sx + this.camera.x, wy: sy + this.camera.y }; }
  mouseWorld() { return this.screenToWorld(this.mouse.sx, this.mouse.sy); }

  invGet(type) { return this.inventory.blocks.get(type) ?? 0; }
  invAdd(type, n = 1) { this.inventory.blocks.set(type, this.invGet(type) + n); }
  invSpend(type, n = 1) {
    const have = this.invGet(type);
    if (have < n) return false;
    this.inventory.blocks.set(type, have - n);
    return true;
  }

  update(dt) {
    const speed = 300;
    let dx = 0, dy = 0;
    if (this.isDown("ArrowLeft") || this.isDown("a")) dx -= 1;
    if (this.isDown("ArrowRight") || this.isDown("d")) dx += 1;
    if (this.isDown("ArrowUp") || this.isDown("w")) dy -= 1;
    if (this.isDown("ArrowDown") || this.isDown("s")) dy += 1;
    if (dx || dy) { this.camera.x += dx * speed * dt; this.camera.y += dy * speed * dt; }

    if (this.mouse.clicked && this.sm?.scene) this.tools.useCurrentTool(this.sm.scene);
  }
}

class Toolbelt {
  constructor(player) {
    this.player = player;
    this.toolIndex = 0;
    this.tools = {
      0: { name: "Hand", action: (scene) => {
        const { wx, wy } = this.player.mouseWorld();
        for (const ent of scene.clickables) {
            ent.interaction?.(scene, this.player);
        }
      }},
      1: { name: "Shovel", action: (scene) => {
        const { wx, wy } = this.player.mouseWorld();
        const block = scene.getBlockAt(wx, wy);
        if (block) { scene.removeBlockAt(wx, wy); this.player.invAdd(block.type, 1); }
      }},
      2: { name: "Placer", action: (scene) => {
        const { wx, wy } = this.player.mouseWorld();
        const type = this.player.inventory.placeIndex;
        if (type <= 0) return;
        if (this.player.invGet(type) <= 0) return;
        // only place into empty
        if (scene.getBlockAt(wx, wy)) return;
        scene.placeBlockAt(wx, wy, type);
        this.player.invSpend(type, 1);
      }},
      3: { name: "HeartWand", action: (scene) => {
        const { wx, wy } = this.player.mouseWorld();
        scene.addEntity(new HeartEntity(wx, wy));
        const vx = (Math.random() - 0.5) * 80;
        const vy = (Math.random() - 0.5) * 80;
        scene.addEntity(new FloatingHeart(wx, wy, { vx, vy, life: 2.8 + Math.random() * 1.2 }))

      }}
    };
  }

  currentTool() { return this.tools[this.toolIndex] ?? this.tools[0]; }
  useCurrentTool(scene) { this.currentTool().action?.(scene); }
}

// ----------------- drawer -----------------
class Drawer {
  constructor(camera, canvas, sm) {
    this.camera = camera;
    this.canvas = canvas;
    this.sm = sm;
  }

  worldToScreen(wx, wy) { return { sx: wx - this.camera.x, sy: wy - this.camera.y }; }

  drawBackground(now) {
    //time come later. midnight for rn
    const w = canvas.width, h = canvas.height;

    // sky gradient
    const sky = ctx.createLinearGradient(0, 0, 0, h);
    sky.addColorStop(0, "#071a2a");
    sky.addColorStop(1, "#0b3b3a");
    ctx.fillStyle = sky;
    ctx.fillRect(0, 0, w, h);

    // cheap stars
    if (backgroundSettings.stars.enabled) {
      const par = backgroundSettings.stars.panSpeed;
      const ox = this.camera.x * par;
      const oy = this.camera.y * par;

      ctx.save();
      ctx.fillStyle = backgroundSettings.stars.colors.midnight;
      for (let i = 0; i < 180; i++) {
        const sx = (hash2i(i, 1, 777) % w) - (ox % w);
        const sy = (hash2i(i, 2, 999) % h) - (oy % h);
        ctx.globalAlpha = 0.2 + ((hash2i(i, 3, 555) & 255) / 255) * 0.6;
        ctx.fillRect((sx + w) % w, (sy + h) % h, 1, 1);
      }
      ctx.restore();
    }

    // hills line (1D noise)
    if (backgroundSettings.hills.enabled) {
      const hill = backgroundSettings.hills;
      const { r, g, b } = hexToRgb(hill.colors.midnight);
      const baseline = h * 0.85;
      const freq = hill.frequency ?? 0.004;

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(0, h);
      for (let x = 0; x <= w; x++) {
        const nx = (x + this.camera.x * hill.panSpeed) * freq + now * 0.00008;
        const n = noise1D(nx, 1000);
        const y = baseline - n * (hill.hillAmplitudes[0] * 0.25);
        ctx.lineTo(x, y);
      }
      ctx.lineTo(w, h);
      ctx.closePath();
      ctx.fillStyle = `rgba(${r},${g},${b},0.95)`;
      ctx.fill();
      ctx.restore();
    }
  }
  drawWorldBlocks(world) {
    for (const ch of world.visibleChunks) {
      const x0 = ch.cx * chunkSize * blockSize;
      const y0 = ch.cy * chunkSize * blockSize;

      for (const [k, b] of ch.blocks) {
        const [bx, by] = k.split(",").map(Number);
        const wx = x0 + bx;
        const wy = y0 + by;
        const sx = wx - this.camera.x;
        const sy = wy - this.camera.y;

        if (sx + blockSize < 0 || sy + blockSize < 0 || sx > canvas.width || sy > canvas.height) continue;

        const tx = Math.floor(wx / blockSize);
        const ty = Math.floor(wy / blockSize);

        ctx.fillStyle = tileColor(b.type, tx, ty);
        ctx.fillRect(sx, sy, blockSize, blockSize);
      }
    }
  }
  drawEntities(entities) {
    const sorted = [...entities].sort((a, b) => (a.z - b.z) || (a.wy - b.wy));
    for (const e of sorted) e.draw(ctx, this.camera);
  }
  drawHUD(player) {
    const tool = player.tools.currentTool();
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.fillRect(10, 10, 260, 70);
    ctx.fillStyle = "white";
    ctx.font = "14px system-ui, sans-serif";
    ctx.fillText(`Tool: ${tool?.name ?? "?"} (1-4)`, 18, 32);
    ctx.fillText(`Blocks: grass=${player.invGet(1)} dirt=${player.invGet(2)} stone=${player.invGet(3)}`, 18, 52);
    ctx.fillText(`PlaceIndex: ${player.inventory.placeIndex} (Z/X to change)`, 18, 70);
    ctx.restore();
  }
  drawPetalShape(ctx, shapeId, scale = 1) {
    const shape = petalShapes[shapeId] ?? petalShapes.triangle;
    if (Array.isArray(shape)) {
        ctx.beginPath();
        ctx.moveTo(shape[0].x * scale, shape[0].y * scale);
        for (let i = 1; i < shape.length; i++) {
        ctx.lineTo(shape[i].x * scale, shape[i].y * scale);
        }
        ctx.closePath();
        ctx.fill();
        return;
    }
    if (shape.arc) {
        ctx.beginPath();
        ctx.ellipse(
        shape.arc.x * scale,
        shape.arc.y * scale,
        shape.radiusX * scale,
        shape.radiusY * scale,
        0, 0, Math.PI * 2
        );
        ctx.fill();
    }
  }
  drawFlowerStamp(ctx, f, opts = {}) {
    const {
        headR = 6,
        centerR = 2.2,
        petalOffset = 0.9, 
        petalScale = 3.2,
    } = opts;

    const petalCount = f.petalCount ?? 6;
    const shapeId = f.petalShapeId ?? "triangle";
    ctx.save();
    ctx.fillStyle = f.color ?? "rgb(220,120,220)";

    for (let i = 0; i < petalCount; i++) {
        const a = (Math.PI * 2 * i) / petalCount;
        const px = Math.cos(a) * headR * petalOffset;
        const py = Math.sin(a) * headR * petalOffset;

        ctx.save();
        ctx.translate(px, py);
        ctx.rotate(a);
        this.drawPetalShape(ctx, shapeId, petalScale);
        ctx.restore();
    }
    ctx.fillStyle = "#ffd700";
    ctx.beginPath();
    ctx.arc(0, 0, centerR, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }
}

// ----------------- a concrete scene -----------------
class GardenScene {
  constructor() {
    this.world = new World();
    this.clickables = new Set(); 
    this.entities = new Set();
  }

  onEnter(sm, player) {
    player.sm = sm;
    player.camera.x = -canvas.width / 2;
    player.camera.y = 0;

    player.invAdd(1, 200);
    player.invAdd(2, 200);
    player.invAdd(3, 200);
  }

  getBlockAt(wx, wy) { return this.world.getBlockAt(wx, wy); }
  placeBlockAt(wx, wy, type) { this.world.setBlockAt(wx, wy, type); }
  removeBlockAt(wx, wy) { this.world.removeBlockAt(wx, wy); }
  addEntity(ent) { this.entities.add(ent); }

  update(sm, dt) {
    this.world.updateVisible(sm.player.camera);

    for (const e of this.entities) e.update(dt);
    for (const e of this.entities) if (!e.alive) this.entities.delete(e);

    this.clickables.clear();
    for (const e of this.entities) e.addToClickable?.({ clickables: this.clickables });
  }

  drawWorld(sm, ctx, camera) {
  }

  drawOverlay(sm, ctx) {
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "24px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Garden Scene", canvas.width / 2, 42);
    ctx.restore();
  }
}

// ----------------- bootstrap -----------------
const player = new Player();

const scenes = {
  garden: new GardenScene()
};

const SM = new SceneManager(
  {
   garden: scenes.garden
  },
  "garden",
  player
);

window.addEventListener("keydown", (e) => {
  if (e.key === "1") player.tools.toolIndex = 0;
  if (e.key === "2") player.tools.toolIndex = 1;
  if (e.key === "3") player.tools.toolIndex = 2;
  if (e.key === "4") player.tools.toolIndex = 3;

  if (e.key === "z") player.inventory.placeIndex = Math.max(1, player.inventory.placeIndex - 1);
  if (e.key === "x") player.inventory.placeIndex = Math.min(3, player.inventory.placeIndex + 1);
});

// ----------------- main loop -----------------
function loop(now) {
  if (!loop.last) loop.last = now;
  const dt = Math.min(0.05, (now - loop.last) / 1000);
  loop.last = now;

  player.update(dt);
  SM.update(dt);

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // background
  SM.drawer.drawBackground(now);

  // world blocks (from current scene)
  const sceneObj = scenes.garden;
  SM.drawer.drawWorldBlocks(sceneObj.world);

  // entities
  SM.drawer.drawEntities(sceneObj.entities);

  // HUD + overlays
  SM.drawer.drawHUD(player);
  SM.drawOverlay(ctx);

  player.beginFrame();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

const canvas = document.getElementById("canvas");
const ctx    = canvas.getContext("2d");

const keys = {};
//mouse x y
window.addEventListener("mousemove", e => {
    const rect = canvas.getBoundingClientRect();
    keys["mousex"] = e.clientX - rect.left;
    keys["mousey"] = e.clientY - rect.top;
});
// mouse
window.addEventListener("mousedown", e => keys["mouse"+e.button] = true);
window.addEventListener("mouseup",   e => keys["mouse"+e.button] = false);
// keyboard
window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup",   e => keys[e.key.toLowerCase()] = false);


class TimeManager {
    constructor() {
        this.systems = []; // anything with update(dt)
    }
    add(system) {
        this.systems.push(system);
    }
    remove(system) {
        this.systems = this.systems.filter(s => s !== system);
    }
    update(dt) {
        for (const s of this.systems) {
            if (s && typeof s.update === "function") {
                s.update(dt);
            }
        }
    }
}

class AbilityManager {
    constructor(world) {
        this.world = world;
        this.queue = []; // [{ caster, target, data, ... }]
    }
    enqueue(ability) {
        this.queue.push(ability);
    }
    update(dt) {
        // process abilities in order
        for (let i = 0; i < this.queue.length; ) {
            const a = this.queue[i];
            // ability.update returns true if still active, false if done
            const alive = a.update ? a.update(dt, this.world) : false;
            if (!alive) this.queue.splice(i, 1);
            else i++;
        }
    }
}

// -----------------------------------------------------
// WorldEntity  // base for everything in the arena
// -----------------------------------------------------
let NEXT_ID = 1;

class WorldEntity {
    constructor(world, x = 0, z = 0) {
        this.id    = NEXT_ID++;
        this.world = world;
        this.x     = x;
        this.z     = z;
        this.vx    = 0;
        this.vz    = 0;
        this.alive = true;
    }
    update(dt /*, world */) {
        this.x += this.vx * dt;
        this.z += this.vz * dt;
    }
    draw(ctx, camera) {
        // override in subclasses
    }
}

// -----------------------------------------------------
// AreaEffect  // stuff like AOE zones, DoT areas, etc.
// Projectile  // bullets, projectiles
// Collidables // things that can collide
// -----------------------------------------------------
class AreaEffect extends WorldEntity {
    // extra fields later: radius, duration, effectType, etc.
}

class Projectile extends WorldEntity {
    constructor(world, x, z) {
        super(world, x, z);
        this.lifetime = 1.5; // seconds
        this.radius   = 4;
    }
    update(dt, world) {
        super.update(dt, world);
        this.lifetime -= dt;
        if (this.lifetime <= 0) this.alive = false;
        // TODO: collision with Collidables
    }
    draw(ctx, camera) {
        const { sx, sz } = camera.worldToScreen(this.x, this.z);
        ctx.fillStyle = "yellow";
        ctx.beginPath();
        ctx.arc(sx, sz, this.radius * camera.zoom * 0.5, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Collidables extends WorldEntity {
    constructor(world, x, z, radius = 8) {
        super(world, x, z);
        this.radius = radius;
    }
    // TODO: add collision helpers later
}

// -----------------------------------------------------
// Space  // stand-in for chunk stuff / arena space
// -----------------------------------------------------
class Space {
    constructor(width, height) {
        this.width  = width;
        this.height = height;
    }
    clamp(x, z) {
        return {
            x: Math.max(0, Math.min(this.width,  x)),
            z: Math.max(0, Math.min(this.height, z))
        };
    }
    randomPoint() {
        return {
            x: Math.random() * this.width,
            z: Math.random() * this.height
        };
    }
}

// -----------------------------------------------------
// Camera
// -----------------------------------------------------
class Camera {
    constructor() {
        this.x      = 0;
        this.z      = 0;
        this.zoom   = 3;
        this.target = null;
    }
    follow(entity) {
        this.target = entity;
    }
    update(dt) {
        if (!this.target) return;
        const lerp = 10 * dt;
        this.x += (this.target.x - this.x) * lerp;
        this.z += (this.target.z - this.z) * lerp;
    }
    worldToScreen(x, z) {
        return {
            sx: (x - this.x) * this.zoom + canvas.width  / 2,
            sz: (z - this.z) * this.zoom + canvas.height / 2
        };
    }
}

// -----------------------------------------------------
// World  // pretend Workspace
// -----------------------------------------------------
class World {
    constructor(space) {
        this.space       = space;
        this.entities    = [];
        this.projectiles = [];
        this.areaEffects = [];
        this.spawnField = null;
    }
    addEntity(e)      { this.entities.push(e);      return e; }
    addProjectile(p)  { this.projectiles.push(p);   return p; }
    addAreaEffect(a)  { this.areaEffects.push(a);   return a; }
   setSpawnField(field) {
        this.spawnField = field;
    }
    update(dt) {
            if (this.spawnField) {
            this.spawnField.update(dt);
        }
        this.entities.forEach(e    => e.update(dt, this));
        this.projectiles.forEach(p => p.update(dt, this));
        this.areaEffects.forEach(a => a.update(dt, this));

        this.entities    = this.entities.filter(e => e.alive);
        this.projectiles = this.projectiles.filter(p => p.alive);
        this.areaEffects = this.areaEffects.filter(a => a.alive);
    }

    draw(ctx, camera) {
        // background
        ctx.fillStyle = "#6aa56a";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // draw things
        this.areaEffects.forEach(a => a.draw(ctx, camera));
        this.entities.forEach(e    => e.draw(ctx, camera));
        this.projectiles.forEach(p => p.draw(ctx, camera));
    }
}
class SpawnField {
    constructor(world, player, options = {}) {
        this.world  = world;
        this.player = player;

        // Configurable
        this.radius          = options.radius || 120;
        this.innerNoSpawn    = options.innerNoSpawn || 40; // avoid spawning on top of player
        this.maxWild         = options.maxWild || 6;
        this.spawnInterval   = options.spawnInterval || 2.5;

        this.timer = 0;
        this.speciesPool = options.speciesPool || [ SpeciesDB.Cat, SpeciesDB.Dog ];
    }

    update(dt) {
        this.timer += dt;

        // try spawn
        if (this.timer >= this.spawnInterval) {
            this.timer = 0;
            this.trySpawn();
        }

        // despawn out of radius
        this.cleanup();
    }

    trySpawn() {
        const currentWild = this.world.entities.filter(e => e instanceof WildEntity).length;
        if (currentWild >= this.maxWild) return;

        // Choose random species
        const species = this.speciesPool[
            Math.floor(Math.random() * this.speciesPool.length)
        ];

        // Get a random spawn point
        const pos = this.randomSpawnPoint();
        if (!pos) return;

        this.world.addEntity(new WildEntity(this.world, species, pos.x, pos.z));
    }

    randomSpawnPoint() {
        const px = this.player.x;
        const pz = this.player.z;

        for (let i = 0; i < 10; i++) { // try up to 10 random samples
            const angle = Math.random() * Math.PI * 2;
            const dist  = this.innerNoSpawn + Math.random() * (this.radius - this.innerNoSpawn);

            const x = px + Math.cos(angle) * dist;
            const z = pz + Math.sin(angle) * dist;

            // clamp inside space
            if (x < 0 || x > this.world.space.width) continue;
            if (z < 0 || z > this.world.space.height) continue;

            return { x, z };
        }

        return null; // couldn't find spot
    }

    cleanup() {
        const px = this.player.x;
        const pz = this.player.z;

        this.world.entities = this.world.entities.filter(e => {
            if (!(e instanceof WildEntity)) return true;

            const dx = e.x - px;
            const dz = e.z - pz;
            const dist = Math.hypot(dx, dz);

            if (dist > this.radius * 1.8) {  // smaller pop in/out by adding buffer
                return false; // despawn
            }

            return true;
        });
    }
}

// -----------------------------------------------------
// Player  // pretend base Roblox player
// -----------------------------------------------------
//read in tick
class Player extends Collidables {
    constructor(world, x, z) {
        super(world, x, z, 10);
        this.speed         = 80;
        this.roster        = []; // RosterEntity list
        this.activeCreature = null;
        this.activeCreatureCommands = null;
        this.autoCommands = {creatureFollow: false};
    }

    update(dt, world) {
        let dx = 0, dz = 0;
        if (keys["w"]) dz -= 1;
        if (keys["s"]) dz += 1;
        if (keys["a"]) dx -= 1;
        if (keys["d"]) dx += 1;

        const len = Math.hypot(dx, dz) || 1;
        this.vx = (dx / len) * this.speed;
        this.vz = (dz / len) * this.speed;

        super.update(dt, world);

        const clamped = world.space.clamp(this.x, this.z);
        this.x = clamped.x;
        this.z = clamped.z;
    }
    inputToPlayerCommands() {
        const clickLocation = { x: keys["mousex"], y: keys["mousey"] };
        return { clickLocation };
    }
    mapInputToActiveCreatureCommands() {
        this.inputToPlayerCommands();
        if (!this.activeCreature) return;
        //dist from creature to player
        if (this.autoCommands.creatureFollow) {
            const distX = this.x - this.activeCreature.x;
            const distZ = this.z - this.activeCreature.z;
            const distance = Math.hypot(distX, distZ);
            if (distance > this.activeCreature.followDistance) {
                this.activeCreature.autoCommands.followOwner = true;
            }
        }
        

        let cmd = { moveX: 0, moveZ: 0 };
        //mouse to world coords

        //keys to ability commands

        this.activeCreatureCommands = cmd;
        this.roster[0].brain.setMovement(dx, dz)

    }


    draw(ctx, camera) {
        const { sx, sz } = camera.worldToScreen(this.x, this.z);
        ctx.fillStyle = "#222";
        ctx.fillRect(sx - 6, sz - 6, 12, 12);
    }
}

// Common shape for commands
const COMMAND = {
    MOVE: "move",
    ABILITY: "ability",
    FOLLOW: "follow",
    STOP: "stop"
};
class Entity extends Collidables {
    constructor(world, species, x, z) {
        super(world, x, z, 8);
        this.species = species;
        this.data = {
            hp: species.baseHP,
            atk: species.baseATK,
            spd: species.baseSPD
        };

        this.currentCommand = null;
        this.brain = null;
    }

    applyCommand(cmd) {
        this.currentCommand = cmd;
    }

    update(dt, world) {
        if (this.currentCommand) {
            switch (this.currentCommand.type) {
                case COMMAND.MOVE:
                    const {dx, dz} = this.currentCommand;
                    const len = Math.hypot(dx, dz) || 1;
                    this.vx = (dx / len) * this.data.spd;
                    this.vz = (dz / len) * this.data.spd;
                    break;

                case COMMAND.STOP:
                    this.vx = 0;
                    this.vz = 0;
                    break;

                case COMMAND.ABILITY:
                    // ability codes will be processed by AbilityManager
                    break;
            }
        }

        super.update(dt, world);
    }
    draw(ctx, camera) {
        const { sx, sz } = camera.worldToScreen(this.x, this.z);
        ctx.fillStyle = this.species.color || "#f0f";
        ctx.fillRect(sx - 5, sz - 5, 10, 10);
    }

}
class BotController {
    constructor(entity) {
        this.entity = entity;
        this.inputs = {};
        this.outputs = {};
    }

    update(dt, world) {
        this.gatherInputs(dt, world);
        this.decide(dt, world);
        this.sendCommands(dt, world);
    }

    gatherInputs() {}
    decide() {}
    sendCommands() {}
}
class AIBotController extends BotController {
    constructor(entity) {
        super(entity);
        this.moveTarget = null;
        this.detectionRadius = 50;
    }

    gatherInputs(dt, world) {
        this.inputs.nearby = [];

        for (const other of world.entities) {
            if (other === this.entity) continue;
            const dx = other.x - this.entity.x;
            const dz = other.z - this.entity.z;
            const dist = Math.hypot(dx, dz);

            if (dist < this.detectionRadius) {
                this.inputs.nearby.push({other, dx, dz, dist});
            }
        }
    }

    decide(dt, world) {
        if (this.moveTarget) {
            const dx = this.moveTarget.x - this.entity.x;
            const dz = this.moveTarget.z - this.entity.z;
            this.outputs.command = { type: COMMAND.MOVE, dx, dz };
        } else {
            this.outputs.command = { type: COMMAND.STOP };
        }
    }

    sendCommands() {
        this.entity.applyCommand(this.outputs.command);
    }
}

class PlayerBotController extends BotController {
    constructor(entity, player) {
        super(entity);
        this.player = player;
    }

    gatherInputs(dt, world) {
        let dx = 0, dz = 0;

        if (keys["w"]) dz -= 1;
        if (keys["s"]) dz += 1;
        if (keys["a"]) dx -= 1;
        if (keys["d"]) dx += 1;

        this.inputs.move = { dx, dz };
    }

    decide(dt, world) {
        const {dx, dz} = this.inputs.move;

        if (dx !== 0 || dz !== 0) {
            this.outputs.command = {
                type: COMMAND.MOVE,
                dx, dz
            };
        } else {
            this.outputs.command = { type: COMMAND.STOP };
        }
    }

    sendCommands() {
        this.entity.applyCommand(this.outputs.command);
    }
}
class TickMovementController extends BotController {
    constructor(entity) {
        super(entity);
        this.pendingMove = { dx: 0, dz: 0 };
    }

    // Player sets movement each tick:
    setMovement(dx, dz) {
        this.pendingMove.dx = dx;
        this.pendingMove.dz = dz;
    }

    gatherInputs() {}
    
    decide(dt, world) {
        const {dx, dz} = this.pendingMove;

        if (dx !== 0 || dz !== 0) {
            this.outputs.command = {
                type: COMMAND.MOVE,
                dx, dz
            };
        } else {
            this.outputs.command = { type: COMMAND.STOP };
        }
    }

    sendCommands() {
        this.entity.applyCommand(this.outputs.command);
    }
}
class AdvancedAIBotController extends BotController {
    constructor(entity) {
        super(entity);

        this.focus = null;
        this.observed = [];

        this.selfHealth = 1;
        this.totalFightFlight = 0;

        this.enemyPressures = [];
        this.teamPressures = [];

        this.requestedPosition = { x: entity.x, z: entity.z };
    }

    update(dt, world) {
        this.observe(world);
        this.weighSelf();
        this.scanEntities();

        this.chooseFocus();
        this.chooseSpot();

        this.decideAttacks();
        this.decideMovement();

        this.observed.length = 0; // reset
    }

    // ============================
    // 1. OBSERVE
    // ============================
    observe(world) {
        for (const e of world.entities) {
            if (e !== this.entity) {
                this.observed.push(e);
            }
        }
    }

    // ============================
    // 2. SELF-WEIGHT
    // ============================
    weighSelf() {
        const e = this.entity;
        this.selfHealth = e.data.hp / e.species.baseHP;
        this.totalFightFlight = (this.selfHealth - 0.5) * 2;
    }

    // ============================
    // 3. PRESSURE ANALYSIS
    // ============================
    scanEntities() {
        this.enemyPressures = [];
        this.teamPressures = [];

        const me = this.entity;

        for (const e of this.observed) {
            const dx = e.x - me.x;
            const dz = e.z - me.z;
            const dist = Math.hypot(dx, dz);
            const angle = Math.atan2(dz, dx);

            const pressure = {
                e,
                health: e.data.hp / e.species.baseHP,
                dist,
                angle
            };

            if (e.team !== me.team) {
                this.enemyPressures.push(pressure);
            } else {
                this.teamPressures.push(pressure);
            }
        }
    }

    // ============================
    // 4. DECIDE FOCUS
    // ============================
    chooseFocus() {
        let best = null;
        let score = -Infinity;

        for (const p of this.enemyPressures) {
            const s = (1 - p.health) + (1 / (1 + p.dist));
            if (s > score) {
                score = s;
                best = p.e;
            }
        }

        this.focus = best;
    }

    // ============================
    // 5. CHOOSE POSITION
    // ============================
    chooseSpot() {
        const me = this.entity;
        const spots = [];
        const personal = me.radius || 10;
        const tooCloseDist = personal * 2;

        if (!this.focus) {
            this.requestedPosition = { x: me.x, z: me.z };
            return;
        }

        // no teammates → simple fight/flight
        if (this.teamPressures.length === 0) {
            for (const p of this.enemyPressures) {
                const sign = this.selfHealth > 0.5 ? +1 : -1;

                const x = me.x + Math.cos(p.angle) * personal * sign;
                const z = me.z + Math.sin(p.angle) * personal * sign;

                spots.push({ x, z });
            }
        }
        else {
            // teamwork logic
            for (const ally of this.teamPressures) {
                for (const enemy of this.enemyPressures) {
                    const angleDiff = Math.abs(ally.angle - enemy.angle);

                    let sign;

                    if (angleDiff < Math.PI / 2) {
                        // get in front of ally if weaker
                        sign = ally.health <= this.selfHealth ? +1 : -1;
                    } else {
                        // get behind ally if they can “tank”
                        sign = ally.health >= this.selfHealth ? -1 : +1;
                    }

                    const x = me.x + Math.cos(ally.angle) * personal * sign;
                    const z = me.z + Math.sin(ally.angle) * personal * sign;

                    spots.push({ x, z });
                }
            }
        }

        if (spots.length) {
            let ax = 0, az = 0;
            for (const s of spots) {
                ax += s.x;
                az += s.z;
            }
            ax /= spots.length;
            az /= spots.length;

            this.requestedPosition = { x: ax, z: az };
        } else {
            this.requestedPosition = { x: me.x, z: me.z };
        }
    }
    decideAttacks() {
        const me = this.entity;
        const f = this.focus;

        if (!f) return;

        const dx = f.x - me.x;
        const dz = f.z - me.z;
        const dist = Math.hypot(dx, dz);

        if (dist < me.radius * 2) {
            me.applyCommand({ type: COMMAND.ABILITY, ability: "melee" });
        }
        if (dist < 80) {
            me.applyCommand({
                type: COMMAND.ABILITY,
                ability: "ranged",
                dir: { dx, dz }
            });
        }
    }
    decideMovement() {
        const me = this.entity;

        const dx = this.requestedPosition.x - me.x;
        const dz = this.requestedPosition.z - me.z;

        if (Math.abs(dx) < 1 && Math.abs(dz) < 1) {
            me.applyCommand({ type: COMMAND.STOP });
            return;
        }

        me.applyCommand({
            type: COMMAND.MOVE,
            dx,
            dz
        });
    }
}

class RosterEntity extends Entity {
    constructor(world, species, owner, x, z) {
        super(world, species, x, z);

        this.owner = owner;

        this.owner = owner;
        this.mode = "FOLLOW"; // default
        this.followDistance = 20;

        this.ai = new AIBotController(this);
        this.playerBot = new PlayerBotController(this, owner);
        this.tickBot = new TickMovementController(this);

        this.brain = this.ai; // default
    }
    setMode(mode) {
        this.mode = mode;

        switch (mode) {
            case "FOLLOW":
            case "BATTLE":
                this.brain = this.ai;
                break;

            case "PLAYER":
                this.brain = this.playerBot;
                break;

            case "TICKMOVE":
                this.brain = this.tickBot;
                break;
        }
    }
    setAutonomous() {
        this.brain = new AIBotController(this);
    }

    setFullPlayerControl() {
        this.brain = new PlayerBotController(this, this.owner);
    }

    setTickMovementControl() {
        this.brain = new TickMovementController(this);
    }

    update(dt, world) {
        // Auto-switch behavior
        this.autoModeLogic(world);

        this.brain.update(dt, world);
        super.update(dt, world);
    }
    autoModeLogic(world) {
    if (this.mode === "PLAYER" || this.mode === "TICKMOVE") return;

    // distance to owner
    const dx = this.owner.x - this.x;
    const dz = this.owner.z - this.z;
    const dist = Math.hypot(dx, dz);

    // find enemies near the player
    const enemyNearPlayer = world.entities.some(e =>
        e.team !== this.team &&
        Math.hypot(e.x - this.owner.x, e.z - this.owner.z) < 60
    );

    if (enemyNearPlayer) {
        this.mode = "BATTLE";
        this.brain = this.ai;
    }
    else if (dist > this.followDistance) {
        this.mode = "FOLLOW";
        this.brain = this.ai;
        // AI follow target
        this.ai.moveTarget = { x: this.owner.x, z: this.owner.z };
    }
    else {
        // idle but near player → follow lightly
        this.mode = "FOLLOW";
        this.ai.moveTarget = { x: this.owner.x, z: this.owner.z };
    }
}

}
class WildEntity extends Entity {
    constructor(world, species, x, z) {
        super(world, species, x, z);
        this.brain = new AIBotController(this);
    }

    update(dt, world) {
        this.brain.update(dt, world);
        super.update(dt, world);
    }
}

class BossEntity extends Entity {
    constructor(world, species, x, z) {
        super(world, species, x, z);
        this.phase  = 1;
        this.enrage = false;
        // TODO: scripted patterns
    }
}

// -----------------------------------------------------
// Species definitions (base stats by family/species)
// -----------------------------------------------------
const SpeciesDB = {
    Cat: {
        name:    "Cat",
        baseHP:  40,
        baseATK: 10,
        baseSPD: 30,
        color:   "#f6863a"
    },
    Dog: {
        name:    "Dog",
        baseHP:  55,
        baseATK:  8,
        baseSPD: 24,
        color:   "#3a8df6"
    }
    // TODO: add more families, morph stages, etc.
};

// -----------------------------------------------------
// Simple game wiring
// -----------------------------------------------------
const space      = new Space(300, 300);
const world      = new World(space);
const camera     = new Camera();
const abilities  = new AbilityManager(world);
const time       = new TimeManager();

const player = world.addEntity(new Player(world, 150, 150));
camera.follow(player);

const pet = world.addEntity(
    new RosterEntity(world, SpeciesDB.Cat, player, 140, 150)
);
player.roster.push(pet);

const spawnField = new SpawnField(world, player, {
    radius: 140,
    innerNoSpawn: 50,
    maxWild: 8,
    spawnInterval: 2.2,
    speciesPool: [ SpeciesDB.Cat, SpeciesDB.Dog ]
});

world.setSpawnField(spawnField);

time.add({
    update(dt) {
        world.update(dt);
        abilities.update(dt);
        camera.update(dt);
        world.draw(ctx, camera);
    }
});

// -----------------------------------------------------
// Main loop
// -----------------------------------------------------
let last = performance.now();

function frame(now) {
    const dt = Math.min((now - last) / 1000, 0.033);
    last = now;
    time.update(dt);
    requestAnimationFrame(frame);
}

requestAnimationFrame(frame);

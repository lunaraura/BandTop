const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
class RNG{constructor(seed=123456789){this.s=(seed>>>0)||1;}next(){this.s=(1664525*this.s+1013904223)>>>0;return this.s;}float(){return (this.next()&0xffff)/0x10000;}int(a,b){return a + (this.next()%(b-a+1));}}
// 2D simplex noise
const F2=0.5*(Math.sqrt(3)-1), G2=(3-Math.sqrt(3))/6;
const grad3=[[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
let perm; function reseedNoise(seed=0){ const r=new RNG(seed||1); const p256=new Uint8Array(256); for(let i=0;i<256;i++) p256[i]=i; for(let i=255;i>0;i--){ const j=r.int(0,255); const t=p256[i]; p256[i]=p256[j]; p256[j]=t; } perm=new Uint8Array(512); for(let i=0;i<512;i++) perm[i]=p256[i&255]; } reseedNoise(1234);
function dot2(g,x,y){ return g[0]*x+g[1]*y; }
function noise2(xin,yin){
  let n0=0,n1=0,n2=0;
  const s=(xin+yin)*F2;
  const i=Math.floor(xin+s), j=Math.floor(yin+s);
  const t=(i+j)*G2, X0=i-t, Y0=j-t;
  const x0=xin-X0, y0=yin-Y0;
  let i1,j1; if(x0>y0){ i1=1;j1=0; } else { i1=0;j1=1; }
  const x1=x0-i1+G2, y1=y0-j1+G2;
  const x2=x0-1+2*G2, y2=y0-1+2*G2;
  const ii=i&255, jj=j&255;
  const gi0=perm[ii+perm[jj]]%8;
  const gi1=perm[ii+i1+perm[jj+j1]]%8;
  const gi2=perm[ii+1+perm[jj+1]]%8;
  let t0=0.5-x0*x0-y0*y0; if(t0>0){ t0*=t0; n0=t0*t0*dot2(grad3[gi0],x0,y0); }
  let t1=0.5-x1*x1-y1*y1; if(t1>0){ t1*=t1; n1=t1*t1*dot2(grad3[gi1],x1,y1); }
  let t2=0.5-x2*x2-y2*y2; if(t2>0){ t2*=t2; n2=t2*t2*dot2(grad3[gi2],x2,y2); }
  return 70*(n0+n1+n2);
}

// ===== World params and biome/heightfield =====
const Params = { CELL:20, WATER_BASE:8, SEED:1335 };
const SHAPE = {
  Taiga:{ amp:142, freq:0.018, rough:0.55, base: 2, water: 0 },
  Meadow:{amp:118, freq:0.006, rough:0.30, base: 0, water: 0 },
  Beach:{ amp:106, freq:0.010, rough:0.25, base:-3, water:-1},
  Swamp:{ amp:108, freq:0.004, rough:0.25, base:-1, water: 2 },
};
const BiomeNoise = {
  biomeMix(x, z, seed) {
    const gx = Math.floor(x / Params.CELL);
    const gz = Math.floor(z / Params.CELL);
    const fx = x / Params.CELL - gx;
    const fz = z / Params.CELL - gz;

    const w00 = weightsAtCell(gx, gz, seed);
    const w10 = weightsAtCell(gx + 1, gz, seed);
    const w01 = weightsAtCell(gx, gz + 1, seed);
    const w11 = weightsAtCell(gx + 1, gz + 1, seed);

    const out = {};
    addScaled(out, w00, (1 - fx) * (1 - fz));
    addScaled(out, w10, fx * (1 - fz));
    addScaled(out, w01, (1 - fx) * fz);
    addScaled(out, w11, fx * fz);

    let s = 0;
    for (const v of Object.values(out)) s += v;
    if (s > 1e-6) {
      for (const k in out) {
        out[k] /= s;
      }
    }
    return out;
  },
};

const Heightfield = {
  sample(x, z, seed) {
    const w = BiomeNoise.biomeMix(x, z, seed);
    let amp = 0, freq = 0, rough = 0, base = 0, water = 0;

    for (const [name, wt] of Object.entries(w)) {
      const p = SHAPE[name];
      if (p) {
        amp += wt * p.amp;
        freq += wt * p.freq;
        rough += wt * p.rough;
        base += wt * p.base;
        water += wt * p.water;
      }
    }

    const n = fbm(x, z, seed, freq, rough);
    const nh = clamp(0.5 + 0.5 * n, 0, 1);
    const yG = base + amp * nh;
    const yW = Params.WATER_BASE + water;

    return { yG, yW, weights: w };
  },
};
function weightsAtCell(ix,iz,seed){
  const x=(ix+0.5)*Params.CELL, z=(iz+0.5)*Params.CELL;
  const T = clamp(0.5 + 0.5*noise2(x*0.00035, z*0.00035 + seed*0.11), 0, 1);
  const W = clamp(0.5 + 0.5*noise2(x*0.00070, z*0.00070 + seed*0.37), 0, 1);
  const wTaiga  = (1-T)*(1-W);
  const wMeadow = T*(1-W);
  const wSwamp  = (1-T)*W*0.7 + T*W*0.3;
  const coast   = 0.5 + 0.5*noise2(x*0.00090, z*0.00090 + seed*0.59);
  const near    = clamp(1 - Math.abs(coast - 0.5)*8, 0, 1);
  const wBeach  = near*0.9;
  const s = wTaiga+wMeadow+wSwamp+wBeach || 1;
  return { Taiga:wTaiga/s, Meadow:wMeadow/s, Swamp:wSwamp/s, Beach:wBeach/s };
}
function biomeMix(x,z,seed){
  const gx=Math.floor(x/Params.CELL), gz=Math.floor(z/Params.CELL);
  const fx=x/Params.CELL-gx, fz=z/Params.CELL-gz;
  const w00=weightsAtCell(gx,gz,seed), w10=weightsAtCell(gx+1,gz,seed);
  const w01=weightsAtCell(gx,gz+1,seed), w11=weightsAtCell(gx+1,gz+1,seed);
  const out={}; const add=(t,s)=>{ for(const k in t){ out[k]=(out[k]||0)+t[k]*s; } };
  add(w00,(1-fx)*(1-fz)); add(w10,fx*(1-fz)); add(w01,(1-fx)*fz); add(w11,fx*fz);
  let s=0; for(const v of Object.values(out)) s+=v; for(const k in out) out[k]/=s||1;
  return out;
}
function blend(components){
  const out=[0,0,0]; let total=0;
    for(const [wt,col] of components){
        out[0]+=col[0]*wt; out[1]+=col[1]*wt; out[2]+=col[2]*wt; total+=wt;
    }
    if(total>0){
        out[0]/=total; out[1]/=total; out[2]/=total;
    }
    return out;
}
function rgb(col){ return `rgb(${col[0]|0},${col[1]|0},${col[2]|0})`; }
function mix(c1,c2,t){
  const it=1-t;
    return [
        c1[0]*it + c2[0]*t,
        c1[1]*it + c2[1]*t,
        c1[2]*it + c2[2]*t,
    ];
}
function fbm(x,z,seed,f,rough){
  let sum=0, amp=1; rough=clamp(rough,0.15,0.95);
  for(let i=1;i<=3;i++){ sum += noise2(x*f, z*f + (seed||0)*i*0.137)*amp; f*=2; amp*=rough; }
  return sum;
}
function heightSample(x,z,seed){
  const w = biomeMix(x,z,seed);
  let amp=0,freq=0,rough=0,base=0,water=0;
  for(const [name,wt] of Object.entries(w)){
    const p=SHAPE[name]; if(!p) continue;
    amp += wt*p.amp; freq += wt*p.freq; rough += wt*p.rough; base += wt*p.base; water += wt*p.water;
  }
  const n   = fbm(x,z,seed,freq,rough);
  const nh  = clamp(0.5 + 0.5*n, 0, 1);
  const yG  = base + amp*nh;
  const yW  = Params.WATER_BASE + water;
  return { yG, yW, weights:w };
}

//non-roblox debug
class World{
    constructor(){
        this.seed = 1335
        this.renderer = new Renderer();
        this.chunkManager = new ChunkManager();
        this.player = null;
    }
    tick(){
        if(this.player){
            this.chunkTick(this.player);
            this.chunkRender();
        }
    }
    chunkTick(player){
        const pcx = Math.floor(player.x / (Params.CELL * CELLS_PER_CHUNK));
        const pcz = Math.floor(player.z / (Params.CELL * CELLS_PER_CHUNK));
        for (let dz = -1; dz <= 1; dz++) {
            for (let dx = -1; dx <= 1; dx++) {
                const cx = pcx + dx;
                const cz = pcz + dz;
                if (!this.chunkManager.chunks.has(`${cx},${cz}`)){
                    console.log(`Generating chunk ${cx}, ${cz}`);
                    this.chunkManager.generateChunk(cx, cz);
                } else {
                    const chunk = this.chunkManager.loadChunk(cx, cz);
                }
            }
        }
    }
    chunkRender(){
        //render chunks around player
        this.renderer.render(this.chunkManager.activeChunks);
    }
}
class Renderer{
    constructor(){
        this.cam = {x: 0, z: 0, zoom:0}
    }
    render(chunkdata){
        //render chunkdata to canvas
        for(const chunkKey of chunkdata){
            const chunk = chunkdata.get(chunkKey);
            console.log(chunk)
            for(let iz=0; iz<CELLS_PER_CHUNK; iz++){
                for(let ix=0; ix<CELLS_PER_CHUNK; ix++){
                    const h = chunk.data.get(`${ix},${iz}`);
                    const wx = (chunk.cx*CELLS_PER_CHUNK + ix)*Params.CELL;
                    const wz = (chunk.cz*CELLS_PER_CHUNK + iz)*Params.CELL;
                    const sx = (wx - this.cam.x) * (1 + this.cam.zoom) + canvas.width/2;
                    const sz = (wz - this.cam.z) * (1 + this.cam.zoom) + canvas.height/2;
                    const color = h.yG < h.yW ? [20, 60, 200] : [34, 139, 34];
                    ctx.fillStyle = rgb(color);
                    ctx.fillRect(sx, sz, Params.CELL*(1+this.cam.zoom), Params.CELL*(1+this.cam.zoom));
                }
            }
        }
    }
}

class ChunkManager{
    constructor(){
        this.chunks = new Map();
        this.activeChunks = new Set();
    }
    generateChunk(cx, cz){
        const chunk = new Chunk(cx, cz);
        chunk.generateChunk();
        this.chunks.set(`${cx},${cz}`, chunk);
    }
    loadChunk(cx, cz){
        const chunk = this.chunks.get(`${cx},${cz}`);
    }
    unloadChunk(cx, cz){
        this.activeChunks.delete(`${cx},${cz}`);
    }

}
class Chunk{
    constructor(cx, cz){
        this.cx = cx;
        this.cz = cz;
        this.data = new Map();
    }
    generateChunk(){
        for(let iz=0; iz<CELLS_PER_CHUNK; iz++){
            for(let ix=0; ix<CELLS_PER_CHUNK; ix++){
                const wx = (this.cx*CELLS_PER_CHUNK + ix)*Params.CELL;
                const wz = (this.cz*CELLS_PER_CHUNK + iz)*Params.CELL;
                const h = heightSample(wx, wz, Params.SEED);
                this.data.set(`${ix},${iz}`, h);
            }
        }
    }
}

// ===== Player and camera =====
class Player{
  constructor(x=0,z=0){
    this.x=x; this.z=z;
    this.vx=0; this.vz=0;
    this.speed=120; // world units per second
    this.radius=8;
    this.hp=100; 
    this.wp=null;

    //roblox user-made stuff. Everything else is handled by roblox (hopefully)
    this.inventory = new Inventory();
    this.roster = new Roster();
    this.storedCreatures = new StoringCreature();
    this.FireClient = 0 // pretend this sends commands to roblox server

  }
  update(dt){
    if(this.wp){
      const dx=this.wp.x - this.x, dz=this.wp.z - this.z;
      const L=Math.hypot(dx,dz);
      if(L>1){ this.vx += (dx/L)*this.speed*0.8; this.vz += (dz/L)*this.speed*0.8; }
      if(L<6) this.wp=null;
    }
    // integrate
    this.x += this.vx*dt; this.z += this.vz*dt;
    // damping
    this.vx*=0.86; this.vz*=0.86;
  }
}
//Chunk creation, chunks with biomes and then water that affects the heightmap
//Start spawning flora in the chunk:
//cosmetic flora (trees, shrubs), then flora you can interact with (berry bushes).
//Entities/Creatures exist. The player gains a UI to choose from bear, cat, or dog as their starter
//after choosing, they gain a creature UI and a creature of their choice.
//WorldEntities service listens for that player now and spawns biome-specific creatures around them
class FloraManager {
    constructor() {
        this.buffer = [];
    }
    checkIfWater(x, z, seed) {
        const h = heightSample(x, z, seed);
        return h.yG < h.yW;
    }
    biomeFloraPicker(biome) {
        const floraOptions = {
            Taiga: ['Pine Tree', 'Fir Tree', 'Berry Bush'],
            Meadow: ['Oak Tree', 'Flower Patch', 'Berry Bush'],
            Beach: ['Palm Tree', 'Cactus', 'Seaweed'],
            Swamp: ['Mangrove Tree', 'Reed Patch', 'Mushroom Cluster'],
        };
        return floraOptions[biome] || [];
    }
    spawnFloraInChunk(chunkX, chunkZ, seed) {
        for (let iz = 0; iz < CELLS_PER_CHUNK; iz++) {
            for (let ix = 0; ix < CELLS_PER_CHUNK; ix++) {
                const wx = (chunkX * CELLS_PER_CHUNK + ix) * Params.CELL;
                const wz = (chunkZ * CELLS_PER_CHUNK + iz) * Params.CELL;
                if (this.checkIfWater(wx, wz, seed)) continue;
                const h = heightSample(wx, wz, seed);
                const dominantBiome = dominant(h.weights);
                const floraOptions = this.biomeFloraPicker(dominantBiome);
                if (floraOptions.length > 0) {
                    const rng = new RNG((wx * 73856093) ^ (wz * 19349663) ^ seed);
                    const spawnChance = 0.1; // 10% chance to spawn flora in a cell
                    if (rng.float() < spawnChance) {
                        const floraType = floraOptions[rng.int(0, floraOptions.length - 1)];
                        this.buffer.push({ type: floraType, x: wx, z: wz });
                    }
                }
            }
        }
    }
    playerInteractWithFlora(playerX, playerZ, interactionRadius) {
        this.buffer = this.buffer.filter(flora => {
            const dx = flora.x - playerX;
            const dz = flora.z - playerZ;
            const distSq = dx * dx + dz * dz;
            if (distSq <= interactionRadius * interactionRadius) {
                console.log(`Player interacted with ${flora.type} at (${flora.x.toFixed(1)}, ${flora.z.toFixed(1)})`);
                return false; // Remove flora after interaction
            }
            return true; // Keep flora if not interacted with
        });
    }
    despawnFloraOutsideRadius(playerX, playerZ, despawnRadius) {
        this.buffer = this.buffer.filter(flora => {
            const dx = flora.x - playerX;
            const dz = flora.z - playerZ;
            const distSq = dx * dx + dz * dz;
            return distSq <= despawnRadius * despawnRadius;
        });
    }
}
class CreatureManager {
    constructor() {
        this.entities = [];
    }
    spawnCreature(type, x, z) {
        const entity = new Creature(type, x, z);
        this.entities.push(entity);
        return entity;
    }
    tickEntities(dt) {
        for (const entity of this.entities) {
            // Update entity logic here (movement, behavior, etc.)
        }
    }
    despawnCreature(entity) {
        const index = this.entities.indexOf(entity);
        if (index !== -1) {
            this.entities.splice(index, 1);
        }
    }
}
class RosterService { //validates wild to player-owned creature data
    constructor() {
    }
    wildToPlayerCreature(wildCreature) {
        const playerCreature = new PlayerCreature(wildCreature.type, wildCreature.x, wildCreature.z);
        // Copy relevant data from wildCreature to playerCreature
        return playerCreature;
    }
}
class Roster {
    constructor(){
        this.creatures = [];
    }

}
class StoringCreature{
    constructor(creature, storageData){
        this.creature = creature;
        this.storageData = storageData; // e.g., health, experience, etc.
    }
}
class Inventory{
    constructor(){
        this.items = {};
    }
}
class globalAbilityFunctions{
    constructor(dict){
        this.dict = dict;
    }
}
class WorldEntityManager{
    constructor(type, x, z){
        this.type=type;
        this.x=x; this.z=z;
        this.life = 100;
        this.entityState={};
    }
    createTargetedProjectile(abilityName, targetX, targetZ){
        // Logic to create and launch a projectile towards (targetX, targetZ)
    }
    createFreeProjectile(abilityName, directionX, directionZ){
        // Logic to create and launch a projectile in the direction (directionX, directionZ)
    }
    createFreeAreaEffect(abilityName, centerX, centerZ, radius){
        // Logic to create an area effect at (centerX, centerZ) with the specified radius
    }
    createTargetedAreaEffect(abilityName, targetX, targetZ, radius){
        // Logic to create an area effect centered on a target at (targetX, targetZ) with the specified radius
    }
    tick(dt){
        // Update entity logic here (movement, behavior, etc.)
    }
}
class Projectile{
    constructor(type, x, z, directionX, directionZ, speed){
        this.type=type;
        this.x=x; this.z=z;
        this.directionX=directionX; this.directionZ=directionZ;
        this.speed=speed;
        this.followTarget=null;
    }
}
class AreaEffect{
    constructor(type, centerX, centerZ, radius, duration){
        this.type=type;
        this.centerX=centerX; this.centerZ=centerZ;
        this.radius=radius;
        this.duration=duration;
        this.followTarget=null;
    }
}
class AbilitySet{
    constructor(abilities){
        this.abilities = abilities; // abilities is a dictionary of abilityName -> abilityFunction
    }
    useAbility(abilityName, user, target){
        const abilityFunc = this.abilities[abilityName];
        if(abilityFunc){
            abilityFunc(user, target);
        }
    }
    requestAbilityUse(abilityName, user, target){
        // In a real Roblox environment, this would send a request to the server
        user.FireClient(abilityName, target);
        if(!user.cooldowns.isOnCooldown(abilityName)){
            this.useAbility(abilityName, user, target);
        }
    }
}
class Cooldowns{
    constructor(){
        this.cooldowns = {}; // abilityName -> timeRemaining
    }
    setCooldown(abilityName, duration){
        this.cooldowns[abilityName] = duration;
    }
    tick(dt){
        for(const abilityName in this.cooldowns){
            this.cooldowns[abilityName] -= dt;
            if(this.cooldowns[abilityName] <= 0){
                delete this.cooldowns[abilityName];
            }
        }
    }
    isOnCooldown(abilityName){
        return this.cooldowns.hasOwnProperty(abilityName);
    }
}
class StatsSet{
    constructor(stats){
        this.baseStats = stats; // baseStats is a dictionary of statName -> baseValue
        this.extraStats = {};
        this.finalStats = {};
    }
    recalculateStats(){}
}
class CreatureBrain{
    constructor(entity){}
}
class StatusEffects {
  constructor() {
    this.effects = []; // Array of active effects
  }

  addEffect(effect) {
    this.effects.push(effect);
  }

  tick(dt) {
    this.effects = this.effects.filter(effect => {
      effect.duration -= dt;
      if (effect.duration <= 0) {
        if (effect.onExpire) effect.onExpire();
        return false; // Remove expired effect
      }
      if (effect.onTick) effect.onTick(dt);
      return true; // Keep active effect
    });
  }
}
class Creature{
    constructor(type, x, z){
        this.type=type;
        this.x=x; this.z=z;
        this.entityState={};
        this.requests = {vel: {x:0, z:0}, basicAttack:false};
        
        // Additional properties like health, behavior state, etc. can be added here
        this.cooldowns = new Cooldowns();
        this.abilities = new AbilitySet({});
        this.stats = new StatsSet({});
        this.brain = new CreatureBrain(this);
        this.statusEffects = new StatusEffects(); // Add status effects manager
    }
    tick(dt) {
        this.statusEffects.tick(dt); // Process status effects
        this.cooldowns.tick(dt); // Process cooldowns
        // ...other entity logic...
    }
}
class PlayerCreature extends Creature{
    constructor(type, x, z){
        super(type, x, z);
        this.activeRoster = false;
        this.autonomy = true;
        this.commandQueue = [];
        this.capturable = false;
        this.inPlayerRoster = true;
        this.inPlayerRadius = false;
    }
}
class WildCreature extends Creature{
    constructor(type, x, z){
        super(type, x, z);
        this.autonomy = true;
        this.capturable = true;
        this.inPlayerRoster = false;
        this.inPlayerRadius = false;
    }
}


//things sent to the HUD:
//if starting out: Choose starter HUD
//Options to request more or less chunks seen, etc
//After picking creature: Creature stat HUD
//Creature Abilities and Cooldowns.


// ===== Canvas, input, main loop =====

const keys=new Set();
addEventListener('keydown', e=>{ keys.add(e.code); if(["KeyQ","KeyE"].includes(e.code)) e.preventDefault(); });
addEventListener('keyup', e=>{ keys.delete(e.code); });

document.getElementById('center').onclick = ()=>{ cam.x=player.x; cam.z=player.z; };
document.getElementById('regen').onclick = ()=>{
  seed = (seed*1664525 + 1013904223)>>>0;
  reseedNoise(seed&0xffff);
};
addEventListener('wheel', e=>{
  cam.zoom = clamp(cam.zoom * (e.deltaY<0? 1.1: 0.9), 0.5, 3.0);
}, {passive:true});

function stepInput(dt){
  let ax=0, az=0;
  if(keys.has('KeyW')) az -= 1;
  if(keys.has('KeyS')) az += 1;
  if(keys.has('KeyA')) ax -= 1;
  if(keys.has('KeyD')) ax += 1;
  if(ax||az){
    const L=Math.hypot(ax,az)||1; ax/=L; az/=L;
    const sp = player.speed * (keys.has('ShiftLeft')? 1.8:1.0);
    player.vx += ax*sp; player.vz += az*sp;
  }
  if(keys.has('KeyQ')) cam.zoom = clamp(cam.zoom*0.98, 0.5, 3.0);
  if(keys.has('KeyE')) cam.zoom = clamp(cam.zoom*1.02, 0.5, 3.0);
}

// ===== Render world and player =====
let player=new Player(0,0);
let world=new World();
world.player=player;
let cam={x:0, z:0, zoom:1.0};
const CELLS_PER_CHUNK = 8;

function dominant(w){ let best="Meadow", bw=-1; for(const [k,v] of Object.entries(w)){ if(v>bw){ bw=v; best=k; } } return best; }

// ===== Main loop =====
let last=performance.now()/1000;
function frame(){
  const now=performance.now()/1000, dt=Math.min(0.05, now-last); last=now;
  stepInput(dt);
  player.update(dt);
  world.tick()
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

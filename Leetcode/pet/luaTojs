const Abilities = {};

function toastAt(part, text, color) {
    if (part) {
        AbilityToast.FireAllClients({ part, text, color });
    }
}

function clamp(v, a, b) {
    return Math.max(a, Math.min(b, v));
}

function closestEnemy(ofPet, radius = 40, pool) {
    let best = null;
    let bestD = radius;
    const op = ofPet.HRP.Position;

    const candidates = pool || (_G.AllCreatures || []);
    for (const other of candidates) {
        if (other !== ofPet && other.State !== "Dead" && other.Team !== ofPet.Team) {
            const d = (other.HRP.Position.sub(op)).Magnitude;
            if (d < bestD) {
                best = other;
                bestD = d;
            }
        }
    }
    return best;
}

function approachAndDo(pet, tgt, range = 6, maxTime = 3.0, fn) {
    const my = (pet._actionId || 0) + 1;
    pet._actionId = my;
    pet.State = "Manual";

    task.spawn(() => {
        const t0 = os.clock();
        while (os.clock() - t0 < maxTime) {
            if (pet._actionId !== my) return;
            if (!tgt || tgt.State === "Dead" || !tgt.Model.Parent) break;

            const d = (tgt.HRP.Position.sub(pet.HRP.Position)).Magnitude;
            if (d <= range) break;

            pet.Hum.MoveTo(tgt.HRP.Position);
            for (let i = 0; i < 6; i++) {
                if (pet._actionId !== my) return;
                task.wait(0.05);
            }
        }
        if (pet._actionId !== my) return;
        if (tgt && tgt.State !== "Dead") {
            pet.HRP.CFrame = CFrame.lookAt(pet.HRP.Position, tgt.HRP.Position);
            fn();
        }
        if (pet._actionId === my) pet.State = "Idle";
    });
}

function beginCD(caster, id, seconds) {
    caster.SetCD(id, seconds);
}

// ===== Ability registry: read-only defs =====
const REGISTRY = {};

function def(a) {
    REGISTRY[a.id] = a;
    return a;
}

// Bite
def({
    id: "Bite",
    key: "Q",
    label: "Bite",
    cd: 0.6,
    cast(ctx) {
        const c = ctx.caster;
        let tgt = ctx.target;
        if (!(tgt && tgt.HRP && tgt.State !== "Dead" && tgt.Model.Parent)) {
            tgt = closestEnemy(c, 40);
            if (!tgt) {
                console.log("[Bite] no target");
                return;
            }
        }
        approachAndDo(c, tgt, 6, 3.0, () => {
            tgt.Damage(c, { dtype: "slice", base: 8 });
            beginCD(c, "Bite", 0.6);
            toastAt(tgt.HRP, "BITE!", Color3.fromRGB(255, 210, 120));
        });
    },
});

// Dash
def({
    id: "Dash",
    key: "E",
    label: "Dash",
    cd: 3.0,
    cast(ctx) {
        const c = ctx.caster;
        const look = c.HRP.CFrame.LookVector;
        const bv = new Instance("BodyVelocity");
        bv.MaxForce = new Vector3(1e6, 1e6, 1e6);
        bv.Velocity = look.mul(60);
        bv.Parent = c.HRP;
        game.GetService("Debris").AddItem(bv, 0.2);
        beginCD(c, "Dash", 3.0);
        toastAt(c.HRP, "DASH!", Color3.fromRGB(180, 220, 255));
    },
});

// Stomp
def({
    id: "Stomp",
    key: "R",
    label: "Stomp",
    cd: 5.0,
    cast(ctx) {
        const c = ctx.caster;
        const center = ctx.point || c.HRP.Position.add(c.HRP.CFrame.LookVector.mul(6));
        const r = 8;
        for (const other of (_G.AllCreatures || [])) {
            if (other !== c && other.Team !== c.Team && other.State !== "Dead" && other.HRP) {
                if ((other.HRP.Position.sub(center)).Magnitude <= r) {
                    other.Damage(c, { dtype: "heat", base: 10 });
                }
            }
        }
        beginCD(c, "Stomp", 5.0);
        toastAt(c.HRP, "STOMP!", Color3.fromRGB(255, 180, 120));
    },
});

// Bolt
def({
    id: "Bolt",
    key: "F",
    label: "Bolt",
    cd: 1.2,
    cast(ctx) {
        const c = ctx.caster;
        const tgt = (ctx.target && ctx.target.HRP) ? ctx.target : closestEnemy(c, 60);
        if (!tgt) return;
        tgt.Damage(c, { dtype: "zap", base: 7 });
        beginCD(c, "Bolt", 1.2);
        toastAt(tgt.HRP, "BOLT!", Color3.fromRGB(200, 200, 255));
    },
});

Abilities.Get = function (id) {
    return REGISTRY[id];
};

Abilities.All = function () {
    return REGISTRY;
};

Abilities.GiveDefaults = function (pet, list) {
    const chosen = list || ["Bite", "Dash"];
    pet.Abilities = pet.Abilities || {};
    for (const id of chosen) {
        const defn = REGISTRY[id];
        if (defn) {
            pet.Abilities[id] = {
                id: id,
                key: defn.key,
                label: defn.label,
                cd: defn.cd,
                cast: (caster, ctxOverride) => {
                    const ctx = { caster: caster };
                    if (ctxOverride) {
                        for (const [k, v] of Object.entries(ctxOverride)) {
                            ctx[k] = v;
                        }
                    }
                    defn.cast(ctx);
                },
            };
        }
    }
    return pet.Abilities;
};

const Util = {
    key(cx, cz) {
        return `${cx}|${cz}`;
    },
    rngFor(cx, cz, seed) {
        const hash = (cx * 73856093) ^ (cz * 19349663) ^ (seed * 9167);
        const masked = hash & 0x7fffffff;
        return new Math.seedrandom(masked);
    },
};
const WorldGen = {
    biomeMix(x, z, seed = Params.SEED) {
        return BiomeNoise.biomeMix(x, z, seed);
    },
    heightAt(x, z, seed = Params.SEED) {
        return Height.sample(x, z, seed);
    },
    pickMaterials(weights) {
        return Materials.pickMaterials(weights);
    },
};

const WorldParams = {
    CELL: 20,
    WATER_BASE: 8,
    SEED: 1335,
};

const Biomes = {
    Taiga: {
        ground: 'Snow',
        high: 'Ice',
        density: 1.3,
    },
    Meadow: {
        ground: 'Grass',
        high: 'Rock',
        density: 1.0,
    },
    Beach: {
        ground: 'Sand',
        high: 'Rock',
        density: 0.6,
    },
    Swamp: {
        ground: 'Mud',
        high: 'Ground',
        density: 0.9,
    },
    Mountains: {
        ground: 'Ground',
        high: 'Rock',
        density: 0.7,
    },
    Hills: {
        ground: 'Grass',
        high: 'Grass',
        density: 0.9,
    },
};

const Materials = {
    pickMaterials(weights) {
        let best = 'Meadow';
        let bestW = -1;

        for (const [k, w] of Object.entries(weights)) {
            if (w > bestW) {
                best = k;
                bestW = w;
            }
        }

        const biome = Biomes[best] || Biomes.Meadow;
        return { ground: biome.ground, high: biome.high, biome: best };
    },
};

clamp01 = (value, min, max) => Math.max(min, Math.min(max, value));

const SHAPE = {
    Taiga: { amp: 142, freq: 0.018, rough: 0.55, base: 2, water: 0 },
    Meadow: { amp: 118, freq: 0.006, rough: 0.30, base: 0, water: 0 },
    Beach: { amp: 106, freq: 0.010, rough: 0.25, base: -3, water: -1 },
    Swamp: { amp: 108, freq: 0.004, rough: 0.25, base: -1, water: 2 },
};

function fbm(x, z, seed, f, rough) {
    let sum = 0;
    let amp = 1;
    rough = clamp(rough, 0.15, 0.95);
    for (let i = 1; i <= 3; i++) {
        sum += noise(x * f, z * f, (seed || 0) * i * 0.137) * amp;
        f *= 2;
        amp *= rough;
    }
    return sum;
}

const Heightfield = {
    sample(x, z, seed) {
        const w = BiomeNoise.biomeMix(x, z, seed);
        let amp = 0, freq = 0, rough = 0, base = 0, water = 0;

        for (const [name, wt] of Object.entries(w)) {
            const p = SHAPE[name];
            if (p) {
                amp += wt * p.amp;
                freq += wt * p.freq;
                rough += wt * p.rough;
                base += wt * p.base;
                water += wt * p.water;
            }
        }

        const n = fbm(x, z, seed, freq, rough);
        const nh = clamp(0.5 + 0.5 * n, 0, 1);
        const yG = base + amp * nh;
        const yW = Params.WATER_BASE + water;

        return { yG, yW, weights: w };
    },
};

const P = WorldParams;

const cache = {};

function weightsAtCell(ix, iz, seed = 0) {
    const k = `${ix}|${iz}`;
    if (cache[k]) return cache[k];

    const x = (ix + 0.5) * P.CELL;
    const z = (iz + 0.5) * P.CELL;
    const T = clamp(0.5 + 0.5 * noise(x * 0.00035, z * 0.00035, seed * 0.11), 0, 1);
    const W = clamp(0.5 + 0.5 * noise(x * 0.00070, z * 0.00070, seed * 0.37), 0, 1);

    const wTaiga = (1 - T) * (1 - W);
    const wMeadow = T * (1 - W);
    const wSwamp = (1 - T) * W * 0.7 + T * W * 0.3;

    const coast = 0.5 + 0.5 * noise(x * 0.00090, z * 0.00090, seed * 0.59);
    const nearCoast = clamp(1 - Math.abs(coast - 0.5) * 8, 0, 1);
    const wBeach = nearCoast * 0.9;

    const s = wTaiga + wMeadow + wSwamp + wBeach;
    const out = s < 1e-6 ? { Meadow: 1 } : {
        Taiga: wTaiga / s,
        Meadow: wMeadow / s,
        Swamp: wSwamp / s,
        Beach: wBeach / s,
    };

    cache[k] = out;
    return out;
}

function addScaled(out, t, s) {
    for (const [k, v] of Object.entries(t)) {
        out[k] = (out[k] || 0) + v * s;
    }
}

const BiomeNoise = {
    biomeMix(x, z, seed) {
        const gx = Math.floor(x / P.CELL);
        const gz = Math.floor(z / P.CELL);
        const fx = x / P.CELL - gx;
        const fz = z / P.CELL - gz;

        const w00 = weightsAtCell(gx, gz, seed);
        const w10 = weightsAtCell(gx + 1, gz, seed);
        const w01 = weightsAtCell(gx, gz + 1, seed);
        const w11 = weightsAtCell(gx + 1, gz + 1, seed);

        const out = {};
        addScaled(out, w00, (1 - fx) * (1 - fz));
        addScaled(out, w10, fx * (1 - fz));
        addScaled(out, w01, (1 - fx) * fz);
        addScaled(out, w11, fx * fz);

        let s = 0;
        for (const v of Object.values(out)) s += v;
        if (s > 1e-6) {
            for (const k in out) {
                out[k] /= s;
            }
        }
        return out;
    },
};
// ServerScriptService/Game/AbilityService.js

const clamp02 = (x) => Math.max(0, Math.min(1, x));

const dotProps = (props, comp) => {
  let s = 0;
  for (const [k, coef] of Object.entries(props)) {
    s += (comp[k] || 0) * coef;
  }
  return s;
};

const baseFrom = (move, caster, cat) => {
  const b = move.baseAtk || {};
  const m = move.atkMult || {};
  const cs = caster.stats || {};
  if (cat === Moves.MoveCat.PHY) {
    return (b.pAtk || 0) + (cs.pAtk || 0) * (m.pAtk || 0);
  } else {
    return (b.eAtk || 0) + (cs.eAtk || 0) * (m.eAtk || 0);
  }
};

const computeDamage = (moveId, atkTypeKey, caster, target) => {
  const tdef = target.composite || {};
  const moveType = Moves.MoveTypes[atkTypeKey];
  if (!moveType) return 0;
  const cat = moveType.cat;
  const move = Moves.Melee[moveId] || Moves.Projectile[moveId];
  if (!move) return 0;

  const base = baseFrom(move, caster, cat);
  const flatBypass = clamp01(dotProps(moveType.flatBypass, tdef));
  const resist = clamp01(dotProps(moveType.resistedBy, tdef));

  const after = base * (1 - flatBypass) * (1 - resist);
  if (cat === Moves.MoveCat.PHY) {
    const def = (target.stats && target.stats.def) || 0;
    return Math.max(1, Math.floor(after - 0.3 * def + 0.5));
  } else {
    return Math.max(1, Math.floor(after + 0.5));
  }
};


// effect hook
// const applyBerryEffect = (p, kind) => {
// 	// TODO: call your CreatureService here
// 	if (kind === 'red') {
// 		print((`Heal used by ${p.Name}`));
// 	} else if (kind === 'yellow') {
// 		print((`Strength used by ${p.Name}`));
// 	} else if (kind === 'blue') {
// 		print((`Revive used by ${p.Name}`));
// 	}
// };

// // picking from bush
// const hookBush = (bush) => {
// 	const prompt = findFirstChildOfClass(bush, 'ProximityPrompt');
// 	if (!prompt) return;
// 	let busy = false;
// 	prompt.onTrigger = (player) => {
// 		if (busy) return;
// 		busy = true;

// 		const kind = bush.attributes?.BerryKind;
// 		let uses = Math.max(0, bush.attributes?.Uses || 0);

// 		if ((kind === 'red' || kind === 'yellow' || kind === 'blue') && uses > 0) {
// 			console.log(`Giving ${kind} berry to player ${player.name}`);
// 			uses -= 1;
// 			bush.attributes.Uses = uses;

// 			if (bush.size > 3) {
// 				bush.size -= 0.4;
// 			}

// 			if (uses <= 0) {
// 				console.log(`Berry bush ${bush.name} is depleted and removed.`);
// 			}
// 		}

// 		busy = false;
// 	};
// };

// Simplified and platform-independent version of the code

// Custom tagging system
const taggedObjects = new Map();

function addTag(object, tag) {
  if (!taggedObjects.has(tag)) {
    taggedObjects.set(tag, []);
  }
  taggedObjects.get(tag).push(object);
}

function getTagged(tag) {
  return taggedObjects.get(tag) || [];
}

function removeTag(object, tag) {
  if (taggedObjects.has(tag)) {
    const objects = taggedObjects.get(tag);
    taggedObjects.set(tag, objects.filter((obj) => obj !== object));
  }
}

// Example usage of tagging system
const berryBush = { name: 'BerryBush1', type: 'BasePart' };
addTag(berryBush, 'BerryBush');

for (const inst of getTagged('BerryBush')) {
  if (inst.type === 'BasePart') {
    console.log(`Processing berry bush: ${inst.name}`);
  }
}

// Simplified function to find the first child of a specific type
function findFirstChildOfClass(parent, className) {
  if (!parent || !parent.children) return null;

  for (const child of parent.children) {
    if (child.type === className) {
      return child;
    }
  }
  return null;
}

// Example usage of findFirstChildOfClass
const bush = {
  children: [
    { type: 'ProximityPrompt', name: 'Prompt1' },
    { type: 'OtherType', name: 'OtherChild' },
  ],
};

const prompt = findFirstChildOfClass(bush, 'ProximityPrompt');
if (prompt) {
  console.log(`Found ProximityPrompt: ${prompt.name}`);
}

// Simplified hookBush function
function hookBush(bush) {
  const prompt = findFirstChildOfClass(bush, 'ProximityPrompt');
  if (!prompt) return;

  let busy = false;
  prompt.onTrigger = (player) => {
    if (busy) return;
    busy = true;

    const kind = bush.attributes?.BerryKind;
    let uses = Math.max(0, bush.attributes?.Uses || 0);

    if ((kind === 'red' || kind === 'yellow' || kind === 'blue') && uses > 0) {
      console.log(`Giving ${kind} berry to player ${player.name}`);
      uses -= 1;
      bush.attributes.Uses = uses;

      if (bush.size > 3) {
        bush.size -= 0.4;
      }

      if (uses <= 0) {
        console.log(`Berry bush ${bush.name} is depleted and removed.`);
      }
    }

    busy = false;
  };
}

// Example usage of hookBush
// hookBush({
//   name: 'BerryBush1',
//   attributes: { BerryKind: 'red', Uses: 5 },
//   size: 4,
//   children: [{ type: 'ProximityPrompt', name: 'Prompt1' }],
// });

// Centralized Event System
const EventEmitter = require('events');
const eventEmitter = new EventEmitter();

// Simplified Inventory System
const Inventory = {
  items: {},

  tryUse(player, kind) {
    console.log(`Player ${player.name} is trying to use ${kind}`);
    if (this.items[kind] > 0) {
      this.items[kind] -= 1;
      return true;
    }
    return false;
  },

  addItem(kind, amount) {
    this.items[kind] = (this.items[kind] || 0) + amount;
  },
};

// Simplified Effect Application
function applyBerryEffect(player, kind) {
  console.log(`Applying ${kind} effect to ${player.name}`);
}

// Centralized Event Handling
function setupEventHandlers() {
  eventEmitter.on('useBerry', (player, kind) => {
    if (['red', 'yellow', 'blue'].includes(kind)) {
      if (Inventory.tryUse(player, kind)) {
        applyBerryEffect(player, kind);
      } else {
        console.log(`Player ${player.name} has no ${kind} berries left.`);
      }
    } else {
      console.log(`Invalid berry kind: ${kind}`);
    }
  });
}

// Example Usage
setupEventHandlers();
Inventory.addItem('red', 5);
Inventory.addItem('yellow', 3);
Inventory.addItem('blue', 2);

const player = { name: 'Player1' };
eventEmitter.emit('useBerry', player, 'red');
eventEmitter.emit('useBerry', player, 'yellow');
eventEmitter.emit('useBerry', player, 'blue');
eventEmitter.emit('useBerry', player, 'green'); // Invalid berry kind

// Game configuration class
class GameConfigClient {
  constructor() {
    this.players = new Map();
    this.MIN_R = 3;
    this.MAX_R = 7;
    this.STARTERS = ['Pyro', 'Aqua', 'Terra'];
  }

  addPlayer(playerId) {
    this.players.set(playerId, {
      radiusChunks: 3,
      starterChosen: false,
      starterId: '',
    });
  }

  setRadius(playerId, radius) {
    const player = this.players.get(playerId);
    if (player) {
      player.radiusChunks = Math.max(this.MIN_R, Math.min(this.MAX_R, Math.floor(radius)));
    }
  }

  chooseStarter(playerId, starterId) {
    const player = this.players.get(playerId);
    if (player && !player.starterChosen && this.STARTERS.includes(starterId)) {
      player.starterChosen = true;
      player.starterId = starterId;
    }
  }
}

// Roster management class
class RosterServiceClient {
  constructor() {
    this.rosters = new Map();
  }

  getRoster(playerId) {
    return this.rosters.get(playerId) || { list: {}, active: null };
  }

  chooseStarter(playerId, family) {
    const roster = this.getRoster(playerId);
    if (!roster.list[family]) {
      roster.list[family] = this.createCreature(family);
      roster.active = roster.active || family;
    }
  }

  createCreature(family) {
    return {
      id: family,
      name: family,
      stats: {
        pAtk: 10,
        eAtk: 8,
        def: 6,
        speed: 7,
        maxHP: 30,
        hp: 30,
      },
      abilities: [{ id: 'basic_attack', name: 'Basic Attack', cd: 0.8 }],
    };
  }
}



//JS only stuff
const canvas = document.createElement('canvas');
canvas.width = 800; 
canvas.height = 600;
document.body.appendChild(canvas); 
const ctx = canvas.getContext('2d');

// Game state
const gameState = {
  players: [
    { x: 100, y: 100, vx: 2, vy: 1, color: 'red' },
    { x: 200, y: 150, vx: -1, vy: 2, color: 'blue' },
  ],
};

function update(deltaTime) {
  for (const player of gameState.players) {
    player.x += player.vx * deltaTime;
    player.y += player.vy * deltaTime;

    if (player.x < 0 || player.x > canvas.width) player.vx *= -1;
    if (player.y < 0 || player.y > canvas.height) player.vy *= -1;
  }
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

  // Draw players
  for (const player of gameState.players) {
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.arc(player.x, player.y, 10, 0, Math.PI * 2);
    ctx.fill();

    // Debug info: Draw velocity vector
    ctx.strokeStyle = 'white';
    ctx.beginPath();
    ctx.moveTo(player.x, player.y);
    ctx.lineTo(player.x + player.vx * 10, player.y + player.vy * 10);
    ctx.stroke();
  }
}

// Game loop
let lastTime = 0;
function gameLoop(timestamp) {
  const deltaTime = (timestamp - lastTime) / 1000; // Convert to seconds
  lastTime = timestamp;

  update(deltaTime); // Update game state
  render(); // Render the game state

  requestAnimationFrame(gameLoop); // Loop
}

// Start the game loop
requestAnimationFrame(gameLoop);

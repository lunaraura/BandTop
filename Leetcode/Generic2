// ==== ENGINE CORE ====

// Canvas + context
const canvas = document.getElementById("canvas");
const ctx    = canvas.getContext("2d");

// ----- Input (Keyboard + Mouse) -----
class Input {
    constructor(target = window) {
        this.keys  = {};
        this.mouse = { x: 0, y: 0, down: false };

        target.addEventListener("keydown", e => {
            this.keys[e.code] = true;
        });
        target.addEventListener("keyup", e => {
            this.keys[e.code] = false;
        });

        canvas.addEventListener("mousemove", e => {
            const rect = canvas.getBoundingClientRect();
            this.mouse.x = e.clientX - rect.left;
            this.mouse.y = e.clientY - rect.top;
        });
        canvas.addEventListener("mousedown", () => {
            this.mouse.down = true;
        });
        canvas.addEventListener("mouseup", () => {
            this.mouse.down = false;
        });
    }

    isDown(code) {
        return !!this.keys[code];
    }
}

// ----- Node tree (base for scenes / entities / UI) -----
class Node {
    constructor() {
        /** @type {Node|null} */
        this.parent   = null;
        /** @type {Node[]} */
        this.children = [];
        this.active   = true;
        this.visible  = true;
    }

    addChild(node) {
        if (!node) return;
        node.parent = this;
        this.children.push(node);
        return node;
    }

    removeChild(node) {
        const i = this.children.indexOf(node);
        if (i >= 0) {
            this.children.splice(i, 1);
            node.parent = null;
        }
    }

    update(dt, engine) {
        for (const c of this.children) {
            if (c.active) c.update(dt, engine);
        }
    }

    draw(ctx, engine) {
        for (const c of this.children) {
            if (c.visible) c.draw(ctx, engine);
        }
    }
}

// ----- Scene base -----
class Scene extends Node {
    enter(engine)  {}   // optional
    exit(engine)   {}   // optional
}

// ----- Engine (loop + current scene + input) -----
class Engine {
    constructor(canvas, ctx) {
        this.canvas = canvas;
        this.ctx    = ctx;
        this.input  = new Input(canvas);
        this.scene  = null;
        this.lastTime = performance.now();
    }

    setScene(scene) {
        if (this.scene && this.scene.exit) {
            this.scene.exit(this);
        }
        this.scene = scene;
        if (this.scene && this.scene.enter) {
            this.scene.enter(this);
        }
    }

    start() {
        const step = (now) => {
            const dt = (now - this.lastTime) / 1000;
            this.lastTime = now;

            if (this.scene) {
                this.scene.update(dt, this);

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.scene.draw(this.ctx, this);
            }
            requestAnimationFrame(step);
        };
        requestAnimationFrame(step);
    }
}

// ==== WORLD LAYER ====

// Simple camera: position + zoom
class Camera {
    constructor() {
        this.x = 0;
        this.y = 0;
        this.zoom = 1;
    }

    apply(ctx) {
        ctx.save();
        ctx.scale(this.zoom, this.zoom);
        ctx.translate(-this.x, -this.y);
    }

    restore(ctx) {
        ctx.restore();
    }
}

// WorldScene = a scene with a camera + entity root
class WorldScene extends Scene {
    constructor() {
        super();
        this.camera     = new Camera();
        this.worldRoot  = new Node();  // holds entities
        this.guiRoot    = new Node();  // holds UI
    }

    addEntity(e) { return this.worldRoot.addChild(e); }
    addGui(g)    { return this.guiRoot.addChild(g); }

    update(dt, engine) {
        this.worldRoot.update(dt, engine);
        this.guiRoot.update(dt, engine);
    }

    draw(ctx, engine) {
        // world
        this.camera.apply(ctx);
        this.worldRoot.draw(ctx, engine);
        this.camera.restore(ctx);

        // GUI (screen space)
        this.guiRoot.draw(ctx, engine);
    }
}

// ==== ENTITY SKELETON ====

// Basic 2D entity with position/velocity and a simple draw
class Entity extends Node {
    constructor(x, y, w = 20, h = 20, color = "black") {
        super();
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.w = w;
        this.h = h;
        this.color = color;
    }

    update(dt, engine) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        super.update(dt, engine);
    }

    draw(ctx, engine) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        super.draw(ctx, engine);
    }
}

// ==== EXAMPLE WORLD (for prototyping) ====

// Simple world to show how to use the skeleton
class DemoWorld extends WorldScene {
    constructor() {
        super();
        this.player = new Entity(100, 100, 24, 24, "dodgerblue");
        this.addEntity(this.player);

        // camera follows player
        this.camera.x = 0;
        this.camera.y = 0;
    }

    update(dt, engine) {
        const input = engine.input;

        // basic WASD movement for the player entity
        const speed = 120;
        let vx = 0, vy = 0;
        if (input.isDown("KeyW")) vy -= 1;
        if (input.isDown("KeyS")) vy += 1;
        if (input.isDown("KeyA")) vx -= 1;
        if (input.isDown("KeyD")) vx += 1;

        if (vx !== 0 || vy !== 0) {
            const len = Math.hypot(vx, vy) || 1;
            vx /= len; vy /= len;
        }

        this.player.vx = vx * speed;
        this.player.vy = vy * speed;

        // camera centered on player
        this.camera.x = this.player.x - canvas.width  / 2 / this.camera.zoom;
        this.camera.y = this.player.y - canvas.height / 2 / this.camera.zoom;

        super.update(dt, engine);
    }
}

// ==== BOOTSTRAP ====

const engine   = new Engine(canvas, ctx);
const demoWorld = new DemoWorld();
engine.setScene(demoWorld);
engine.start();

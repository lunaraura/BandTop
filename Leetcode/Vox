import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js';

const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setSize(canvas.width, canvas.height);
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf0f8ff);

const camera = new THREE.PerspectiveCamera(60, canvas.width / canvas.height, 0.1, 1000);
camera.position.set(8, 8, 12);
camera.lookAt(0, 2, 0);

const v = (x, y, z) => {return {x:x,y:y,z:z}}

class Voxel {
    constructor(x, y, z, size, color) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.size = size;
        this.color = color;
    }
    addToScene(scene) {
        const geometry = new THREE.BoxGeometry(this.size, this.size, this.size);
        const material = new THREE.MeshBasicMaterial({ color: this.color });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(this.x, this.y, this.z);
        scene.add(cube);
    }
}

class Flower {
    constructor(pos, birthData = {}){
        this.pos = pos;
        this.dna = birthData;
        this.limits = {}
        this.clusterVoxSpawn = {}

        this.growablePart = []
        this.allParts = []

        this.init()
        this.spawnSeed();
    }
    init(){
        let inherited = this.dna;
        this.limits = {
            stem: {inCluster:5, overall: 15},
            leaf: {inCluster:3, overall: 15},
            flowerBud: {inCluster:1, overall: 3},
            flowerPetal: {inCluster:6, overall: 36},
        }
        //switchcase on how to spawn each voxel in a cluster
        //radius spawns around origin voxel, chain spawns next to last spawned
        //triangle spawns beside two other voxels
        this.clusterVoxSpawn = {
            seed: {stem: {amt:1, type: "chain", dir: 'up'}},
            stem: {stem: {amt: 4, type: "chain", dir: 'up'}, leaf: {amt: 1, type: "chain", dir: 'side'}, flowerBud: {amt: 1, type: "chain", dir: 'up'}},
            leaf: {leaf:{amt: 2, type: "triangle"}, dir: 'side'},
            flowerBud: {flowerPetal: {amt:6, type: "radius", dir: 'side'}}
        }
    }
    spawnSeed(){
        this.newPart('seed', null, this.pos)
    }
    newPart(type, parentWeld, position){
        let color =  0xffffff;
        if (type === 'stem') color = 0x8B4513;
        else if (type === 'leaf') color = 0x00ff00;
        else if (type === 'flowerBud') color = 0xff00ff;
        else if (type === 'flowerPetal') color = 0xffff00;
        else if (type === 'seed') color = 0xaf6600;
        const part = {
            type: type,
            pos: position,
            canGrow: true,
            childPositions: {up: null, down: null, left: null, right: null, front: null, back: null}
        }
        this.growablePart.push(part)
        this.allParts.push(part)
        const voxel = new Voxel(position.x, position.y, position.z, 1, color);
        voxel.addToScene(scene);
    }
    tick(){
        console.log("Tick");
        if (!this.checkLimit()) return null;
        if (this.growablePart.length === 0) return null;

        //pick random growable part
        const growIdx = Math.floor(Math.random() * this.growablePart.length);
        const growPart = this.growablePart[growIdx];
        console.log("Growing part:", growPart.type, "at", growPart.pos);
        //determine what can grow from it
        const possibleSpawns = this.clusterVoxSpawn[growPart.type];
        if (!possibleSpawns) {
            console.log("No possible spawns for this part.");
            growPart.canGrow = false;
            this.growablePart.splice(growIdx, 1);
            return;
        }
        //pick a random spawn type
        const spawnTypes = Object.keys(possibleSpawns).filter(k => k !== 'dir');
        const spawnType = spawnTypes[Math.floor(Math.random() * spawnTypes.length)];
        const spawnData = possibleSpawns[spawnType];
        //determine new voxel position
        const dir = possibleSpawns.dir || 'up';
        const newPos = this.getNewVoxelPosition(growPart.pos, spawnData.type, dir);
        let occupied = false;
        for (const p of this.allParts) {
            if (p.pos.x === newPos.x && p.pos.y === newPos.y && p.pos.z === newPos.z) {
                occupied = true;
                break;
            }
        }
        if (occupied) {
            console.log("Position occupied, cannot grow here.");
            growPart.canGrow = false;
            this.growablePart.splice(growIdx, 1);
            return;
        }
        //create new part
        this.newPart(spawnType, growPart, newPos);
    }
    dirVec(dir){
        switch(dir){
            case 'up': return v(0,1,0);
            case 'down': return v(0,-1,0);
            case 'left': return v(-1,0,0);
            case 'right': return v(1,0,0);
            case 'front': return v(0,0,1);
            case 'back': return v(0,0,-1);
            case 'side': {
                const sides = [v(1,0,0), v(-1,0,0), v(0,0,1), v(0,0,-1)];
                return sides[Math.floor(Math.random() * sides.length)];
            }
            case 'diagonalSide': {
                const sides = [v(1,0,1), v(1,0,-1), v(-1,0,1), v(-1,0,-1)];
                return sides[Math.floor(Math.random() * sides.length)];
            }
            default: return v(0,1,0);
        }
    }
    getNewVoxelPosition(origin, spawnType, dir){
        const dirVector = this.dirVec(dir);
        switch(spawnType){
            case 'chain': {
                return v(origin.x + dirVector.x, origin.y + dirVector.y, origin.z + dirVector.z);
            }
            case 'radius': {
                const angle = Math.random() * Math.PI * 2;
                const radius = 1;
                return v(origin.x + Math.cos(angle) * radius, origin.y, origin.z + Math.sin(angle) * radius);
            }
            case 'triangle': {
                const positions = [
                    v(origin.x + 1, origin.y, origin.z),
                    v(origin.x - 1, origin.y, origin.z),
                    v(origin.x, origin.y, origin.z + 1),
                    v(origin.x, origin.y, origin.z - 1),
                    v(origin.x + 1, origin.y, origin.z + 1),
                    v(origin.x - 1, origin.y, origin.z - 1),
                    v(origin.x + 1, origin.y, origin.z - 1),
                    v(origin.x - 1, origin.y, origin.z + 1),
                ];
                return positions[Math.floor(Math.random() * positions.length)];
            }
            default:
                return v(origin.x, origin.y + 1, origin.z);
        }
    }
    checkLimit(){
        let overallCounts = {};
        for (const part of this.allParts) {
            overallCounts[part.type] = (overallCounts[part.type] || 0) + 1;
        }
        return true;
    }
    checkClusterLimit(partType){
        let clusterCount = 0;
        for (const part of this.allParts) {
            if (part.type === partType) {
                clusterCount++;
            }
        }
        const limit = this.limits[partType];
        if (!limit) return false;
        return clusterCount < limit.inCluster;
    }
    countParts(type) {
        return this.allParts.filter(p => p.type === type).length;
    }
}

const flower = new Flower(v(0,0,0))
setInterval(() => {
    flower.tick();
}, 1000);
function loop() {
    requestAnimationFrame(loop);
    renderer.render(scene, camera);
    scene.rotation.y += 0.01;
}
loop();

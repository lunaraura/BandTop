// ---------- Math helpers ----------
const v = (x = 0, y = 0, z = 0) => ({ x, y, z });
const cloneV = (a) => v(a?.x ?? 0, a?.y ?? 0, a?.z ?? 0);
const add = (a, b) => v((a?.x ?? 0) + (b?.x ?? 0), (a?.y ?? 0) + (b?.y ?? 0), (a?.z ?? 0) + (b?.z ?? 0));
const normRot = cloneV;

const toRadians = (deg = 0) => (deg * Math.PI) / 180;
const wrapDeg = (d) => {
  d = (d ?? 0) % 360;
  return d < -180 ? d + 360 : d > 180 ? d - 360 : d;
};
const wrapRot = (r) => v(wrapDeg(r?.x), wrapDeg(r?.y), wrapDeg(r?.z));

function rotateVector(vec, rot) {
  // Defensive defaults avoid NaN
  const radX = toRadians(rot?.x ?? 0);
  const radY = toRadians(rot?.y ?? 0);
  const radZ = toRadians(rot?.z ?? 0);

  const cosX = Math.cos(radX), sinX = Math.sin(radX);
  const cosY = Math.cos(radY), sinY = Math.sin(radY);
  const cosZ = Math.cos(radZ), sinZ = Math.sin(radZ);

  const x1 = vec.x;
  const y1 = vec.y * cosX - vec.z * sinX;
  const z1 = vec.y * sinX + vec.z * cosX;

  const x2 = x1 * cosY + z1 * sinY;
  const y2 = y1;
  const z2 = -x1 * sinY + z1 * cosY;

  const x3 = x2 * cosZ - y2 * sinZ;
  const y3 = x2 * sinZ + y2 * cosZ;
  const z3 = z2;

  return v(x3, y3, z3);
}

const randRange = (lo, hi) => lo + Math.random() * (hi - lo);
const applyRotVariation = (rot, variation) => {
  const r = normRot(rot);
  r.x += randRange(variation.x.l, variation.x.h);
  r.y += randRange(variation.y.l, variation.y.h);
  r.z += randRange(variation.z.l, variation.z.h);
  return wrapRot(r);
};

// ---------- Plant model ----------
class PlantObject {
  constructor(type, position, rotation, scale) {
    this.type = type;
    this.position = cloneV(position);
    this.rotation = normRot(rotation);
    this.scale = scale;

    this.parts = [];
    this.totalMaxParts = 500;

    this.totalWater = 0;
    this.partTickIndex = 0;

    // Fast counts per type, replaces O(n) filters
    this.typeCounts = new Map();
  }

  _incType(type) {
    this.typeCounts.set(type, (this.typeCounts.get(type) ?? 0) + 1);
  }

  initPart() {
    const part = PlantPart.create(this.type, this.position, this.rotation);
    this.parts.push(part);
    this._incType(part.type);
  }

  collectWaterFromAllParts() {
    let produced = 0;
    for (const part of this.parts) produced += part.produceWater();
    this.totalWater += produced;
  }

  // Two-pass FIFO: sustain first, then 1 spawn-token
  distributeWaterFIFO() {
    if (this.totalWater <= 0) return;

    // Pass 1: sustain
    for (const part of this.parts) {
      if (this.totalWater <= 0) break;
      part.updateNeeds();

      const need = Math.max(0, part.waterNeededSelf - part.allocatedWater);
      const give = Math.min(need, this.totalWater);

      part.allocatedWater += give;
      this.totalWater -= give;
    }

    // Pass 2: spawn token
    for (const part of this.parts) {
      if (this.totalWater <= 0) break;
      part.updateNeeds();

      const need = Math.max(0, (part.waterNeededSelf + part.waterNeededtoSpawn) - part.allocatedWater);
      const give = Math.min(need, this.totalWater);

      part.allocatedWater += give;
      this.totalWater -= give;
    }
  }

  tick() {
    if (this.parts.length === 0) return;

    this.collectWaterFromAllParts();
    this.distributeWaterFIFO();

    const part = this.parts[this.partTickIndex];
    if (!part) return;

    // Part consumes its allocation; leftover returns to reservoir
    this.totalWater += part.stepWithAllocatedWater();

    if (part.canSpawn && this.parts.length < this.totalMaxParts) {
      this.spawnChildrenFrom(part);
      part.canSpawn = false;
    }

    // Correct progression through all parts
    this.partTickIndex = (this.partTickIndex + 1) % this.parts.length;
  }

  spawnChildrenFrom(parent) {
    const spawnTable = predefinitions[parent.type].spawnVar;

    for (const [spawnType, def] of Object.entries(spawnTable)) {
      // Decide your semantics: "max" as GLOBAL cap per type
      const existing = this.typeCounts.get(spawnType) ?? 0;
      if (existing >= def.max) continue;

      // Roll chance once per tick per spawnType (your current behavior)
      if (Math.random() > def.chance) continue;

      const rotOffset = normRot(
        def.rot && def.rot.length
          ? def.rot[Math.floor(Math.random() * def.rot.length)]
          : v(0, 0, 0)
      );

      // Child rotation = parent rot + offset + variation (final)
      let childRot = add(parent.rotation, rotOffset);
      childRot = applyRotVariation(childRot, predefinitions[spawnType].rotVariation);

      // Correct: compute position using child's FINAL rotation
      const stepLen = Math.max(2, parent.magnitude * this.scale);
      const dir = rotateVector(v(0, stepLen, 0), childRot);
      const childPos = add(parent.position, dir);

      const child = PlantPart.create(spawnType, childPos, childRot);
      this.parts.push(child);
      this._incType(child.type);

      if (this.parts.length >= this.totalMaxParts) return;
    }
  }
}

class PlantPart {
  constructor(type, position, rotation, magnitude) {
    this.type = type;
    this.position = cloneV(position);
    this.rotation = normRot(rotation);
    this.magnitude = magnitude;

    this.age = 0;
    this.allocatedWater = 0;

    this.waterNeededSelf = 0;
    this.waterNeededtoSpawn = 0;
    this.canSpawn = false;

    this.def = predefinitions[type];
    this.growth = this.def.growth;
  }

  static create(type, position, rotation) {
    const mag = predefinitions[type].growth.startingMagnitude;
    // apply variation at creation consistently
    const rot = applyRotVariation(rotation, predefinitions[type].rotVariation);
    const p = new PlantPart(type, position, rot, mag);
    p.updateNeeds();
    return p;
  }

  updateNeeds() {
    this.waterNeededSelf = this.growth.needForSustain * this.magnitude;
    this.waterNeededtoSpawn = this.growth.needForSpawn * this.magnitude;
  }

  produceWater() {
    return this.growth.waterCollect * Math.max(0, this.magnitude);
  }

  stepWithAllocatedWater() {
    this.age += 1;
    this.updateNeeds();

    let w = this.allocatedWater;
    this.allocatedWater = 0;

    if (w >= this.waterNeededSelf) {
      w -= this.waterNeededSelf;

      if (w >= this.waterNeededtoSpawn) {
        this.canSpawn = true;
        w -= this.waterNeededtoSpawn;
      } else {
        this.canSpawn = false;
      }
    } else {
      this.canSpawn = false;
      // Optional: drought effect
      this.magnitude = Math.max(0.25, this.magnitude - 0.1);
    }

    return w;
  }
}

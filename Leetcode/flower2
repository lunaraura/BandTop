const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const objects = [];

const v = (x, y, z) => ({ x, y, z });
const add = (a, b) => v(
  (a.x ?? 0) + (b.x ?? 0),
  (a.y ?? 0) + (b.y ?? 0),
  (a.z ?? 0) + (b.z ?? 0)
);
const toRadians = (deg) => (deg * Math.PI) / 180;

function rotateVector(vec, rot) {
  const radX = toRadians(rot.x);
  const radY = toRadians(rot.y);
  const radZ = toRadians(rot.z);

  const cosX = Math.cos(radX), sinX = Math.sin(radX);
  const cosY = Math.cos(radY), sinY = Math.sin(radY);
  const cosZ = Math.cos(radZ), sinZ = Math.sin(radZ);

  const x1 = vec.x;
  const y1 = vec.y * cosX - vec.z * sinX;
  const z1 = vec.y * sinX + vec.z * cosX;

  const x2 = x1 * cosY + z1 * sinY;
  const y2 = y1;
  const z2 = -x1 * sinY + z1 * cosY;

  const x3 = x2 * cosZ - y2 * sinZ;
  const y3 = x2 * sinZ + y2 * cosZ;
  const z3 = z2;

  return v(x3, y3, z3);
}
const cloneV = (a) => v(a.x, a.y, a.z);

const predefinitions = {
    shell: {rotVariation: {x: {h:0, l:0}, y: {h:0, l:0}, z: {h:0, l:0}},
        spawnVar: {stalk: {chance: 0.5, max: 1, rot: [{x: 10}]}, root:{chance: 0.4, max: 2, rot:[{x: -180}]}}, //rot (offset)
        growth: {waterCollect: 1, magBeforeSpawn: 1, startingMagnitude: 1, needForSustain: 0, needForSpawn: 1} 
    },
    root: {rotVariation: {x: {h:0, l:0}, y: {h:30, l:-30}, z: {h:30, l:-30}},
        spawnVar: {root:{chance: 0.5, max: 2, rot:[]}}, 
        growth: {waterCollect: 2, magBeforeSpawn: 2, startingMagnitude: 1, needForSustain: 1, needForSpawn: 2}
    },
    stalk: {rotVariation: {x: {h:5, l:-5}, y: {h:5, l:-5}, z: {h:5, l:-5}},
        spawnVar: {leaf:{chance: 0.3, max: 3, rot:[{x: -45}, {x: 0, y: 45}, {x:0, y:-45}]},
                    flower:{chance: 0.3, max: 1, rot:[{x: 0}]},
                stalk:{chance: 0.6, max: 1, rot:[]}},
        growth: {waterCollect: 1, magBeforeSpawn: 1, startingMagnitude: 2, needForSustain: 1, needForSpawn: 1}
    },
    leaf: {rotVariation: {x: {h:20, l:-20}, y: {h:20, l:-20}, z: {h:20, l:-20}},
        spawnVar: {}, 
        growth: {waterCollect: 3, magBeforeSpawn: 0, startingMagnitude: 1, needForSustain: 1, needForSpawn: 0}
    },
    flower: {rotVariation: {x: {h:30, l:-30}, y: {h:30, l:-30}, z: {h:30, l:-30}},
        spawnVar: {}, 
        growth: {waterCollect: 0, magBeforeSpawn: 0, startingMagnitude: 1, needForSustain: 0, needForSpawn: 0}
    },
    treeTrunk: {rotVariation: {x: {h:5, l:-5}, y: {h:5, l:-5}, z: {h:5, l:-5}},
        spawnVar: {branch:{chance: 0.6, max: 3, rot:[{y: 45}, {y: -45}]},
                    root:{chance: 0.3, max: 2, rot:[{y: -90}]}},
        growth: {waterCollect: 1, magBeforeSpawn: 2, startingMagnitude: 3, needForSustain: 2, needForSpawn: 2}
    },
    branch: {rotVariation: {x: {h:15, l:-15}, y: {h:15, l:-15}, z: {h:15, l:-15}},
        spawnVar: {leaf:{chance: 0.7, max: 4, rot:[{x: -45}, {x: 0, y: 45}, {x:0, y:-45}]},
                    flower:{chance: 0.4, max: 2, rot:[{x: -90}]}},
        growth: {waterCollect: 2, magBeforeSpawn: 1, startingMagnitude: 2, needForSustain: 1, needForSpawn: 1}
    }
}

const normRot = (r) => v(r?.x ?? 0, r?.y ?? 0, r?.z ?? 0);

const wrapDeg = (d) => {
  d = d % 360;
  return d < -180 ? d + 360 : d > 180 ? d - 360 : d;
};
const wrapRot = (r) => v(wrapDeg(r.x), wrapDeg(r.y), wrapDeg(r.z));

class PlantObject {
  constructor(type, position, rotation, scale) {
    this.type = type;
    this.position = cloneV(position);
    this.rotation = normRot(rotation);
    this.scale = scale;
    this.parts = [];
    this.totalMaxParts = 500;
    this.totalWater = 0;
    this.partTickIndex = 0;
    this.splitPartTickPer = 5;
  }

  initPart() {
    let shell = new PlantPart(
      this.type,
      cloneV(this.position),
      cloneV(this.rotation),
      predefinitions[this.type].growth.startingMagnitude
    );
    shell.initTypes();
    shell.applyRotationVariation();
    shell.rotation = wrapRot(shell.rotation); // optional
    this.parts.push(shell);
  }

  tick() {
    let i = this.partTickIndex;
    const part = this.parts[i];
    if (!part) return;

    part.grow();

    if (part.canSpawn) {
      const spawnDefs = predefinitions[part.type].spawnVar;

      for (const spawnType in spawnDefs) {
        const def = spawnDefs[spawnType];

        for (let s = 0; s < def.max; s++) {
          if (Math.random() >= def.chance) continue;

          // Always normalize offsets so x/y/z exist
          const rotOffset = normRot(def.rot?.[s % def.rot.length] ?? v(0, 0, 0));

          // Start from parent rotation + base offset
          let childRot = add(normRot(part.rotation), rotOffset);

          // IMPORTANT: apply variation BEFORE computing the direction/position
          // so position matches the final rotation.
          // We can do this by creating the part first, varying, then computing position,
          // OR by applying variation math directly here. We'll do the first for clarity.
          let newPart = new PlantPart(
            spawnType,
            v(0, 0, 0),                 // temporary; set after we know final rotation
            childRot,
            predefinitions[spawnType].growth.startingMagnitude
          );
          newPart.initTypes();
          newPart.applyRotationVariation();
          newPart.rotation = wrapRot(newPart.rotation); // optional

          // Now compute child position using the FINAL rotation
          // NOTE: consider whether you really want "* this.scale" here.
          // If magnitude is already a “world length”, multiplying by scale will explode spacing.
          const stepLen = part.magnitude * this.scale;
          const dirVec = rotateVector(v(0, stepLen, 0), newPart.rotation);
          newPart.position = add(part.position, dirVec);

          this.parts.push(newPart);
        }
      }

      part.canSpawn = false;
    }

    this.partTickIndex++;
    if (this.partTickIndex >= this.parts.length) this.partTickIndex = 0;
  }
}

class PlantPart {
  constructor(type, position, rotation, magnitude) {
    this.type = type;
    this.position = cloneV(position);
    this.rotation = normRot(rotation);
    this.magnitude = magnitude;
    this.age = 0;
    this.waterNeededSelf = 0;
    this.waterNeededtoSpawn = 0;
    this.waterHas = 0;
    this.canSpawn = false;
  }

  initTypes() {
    const def = predefinitions[this.type];
    this.rotVariation = def.rotVariation;
    this.spawnVar = def.spawnVar;
    this.growth = def.growth;

    this.waterNeededSelf = this.growth.needForSustain * this.magnitude;
    this.waterNeededtoSpawn = this.growth.needForSpawn * this.magnitude;
  }

  applyRotationVariation() {
    // Ensure components exist before +=
    this.rotation = normRot(this.rotation);

    this.rotation.x += Math.random() * (this.rotVariation.x.h - this.rotVariation.x.l) + this.rotVariation.x.l;
    this.rotation.y += Math.random() * (this.rotVariation.y.h - this.rotVariation.y.l) + this.rotVariation.y.l;
    this.rotation.z += Math.random() * (this.rotVariation.z.h - this.rotVariation.z.l) + this.rotVariation.z.l;
  }

  grow() {
    this.age += 1;
    this.waterHas += this.growth.waterCollect * this.magnitude;

    if (this.waterHas >= this.waterNeededSelf) {
      this.waterHas -= this.waterNeededSelf;

      if (this.waterHas >= this.waterNeededtoSpawn) {
        this.canSpawn = true;
        this.waterHas -= this.waterNeededtoSpawn;
      }
    } else {
      this.magnitude -= 0.1;
    }
  }
}
// Example usage:
const plant = new PlantObject("shell", v(0, 0, 0), v(0, 0, 0), 10);
plant.initPart();
objects.push(plant);
setInterval(() => {
    objects.forEach(obj => obj.tick());
}, 100);

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (const obj of objects) {
        for (const part of obj.parts) {
            const screenX = canvas.width / 2 + part.position.x;
            const screenY = canvas.height / 2 - part.position.y;
            ctx.beginPath();
            ctx.arc(screenX, screenY, part.magnitude, 0, 2 * Math.PI);
            ctx.fillStyle = "green";
            ctx.fill();
        }
    }
    requestAnimationFrame(draw);
}
function loop() {
    draw();
    requestAnimationFrame(loop);
}
loop();

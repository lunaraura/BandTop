const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const tileSize = 4;
const chunkSize = 16;
const visibleChunks = 3;

const tileDefinitions = {
    0: {name: "empty", color: "#000", colorVariation: {r: 0, g: 0, b: 0}},
    1: {name: "grass", color: "#0f0", colorVariation: {r: 30, g: 30, b: 30}},
    2: {name: "dirt", color: "#964B00", colorVariation: {r: 30, g: 30, b: 30}},
    3: {name: "stone", color: "#888", colorVariation: {r: 20, g: 20, b: 20}},
    4: {name: "water", color: "#00f", colorVariation: {r: 0, g: 0, b: 50}}
}
const specialTileTypes = {
    0: {name: "empty", color: "#000"},
    1: {name: "flower", color: "#f0f", colorVariation: {r: 30, g: 30, b: 30}},
}

class World {
    constructor() {
        this.chunks = {};
    }
    currentChunk(x, y) {
        const chunkX = Math.floor(x / (chunkSize * tileSize));
        const chunkY = Math.floor(y / (chunkSize * tileSize));
        return this.chunks[`${chunkX},${chunkY}`];
    }
    manageVisibleChunks(playerX, playerY) {
        const centerChunkX = Math.floor(playerX / (chunkSize * tileSize));
        const centerChunkY = Math.floor(playerY / (chunkSize * tileSize));
        for (let y = centerChunkY - visibleChunks; y <= centerChunkY + visibleChunks; y++) {
            for (let x = centerChunkX - visibleChunks; x <= centerChunkX + visibleChunks; x++) {
                const key = `${x},${y}`;
                if (!this.chunks[key]) {
                    const chunk = new Chunk(x, y, chunkSize);
                    chunk.generatePerlin();
                    this.chunks[key] = chunk;
                }
            }
        }
        for (let key in this.chunks) {
            const [chunkX, chunkY] = key.split(',').map(Number);
            if (Math.abs(chunkX - centerChunkX) > visibleChunks || Math.abs(chunkY - centerChunkY) > visibleChunks) {
                delete this.chunks[key];
            }
        }
    }
}
class Chunk {
    constructor(x, y, size) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.tiles = [];
    }
    generate() {

    }
    generateSimple() {
        const allowedTypes = Object.keys(tileDefinitions).map(Number);
        for (let y = 0; y < this.size; y++) {
            const row = [];
            for (let x = 0; x < this.size; x++) {
                const type = allowedTypes[Math.floor(Math.random() * allowedTypes.length)];
                row.push(type);
            }
            this.tiles.push(row);
        }
    }
    generatePerlin() {
        const noise = new SimplexNoise();
        for (let y = 0; y < this.size; y++) {
            const row = [];
            for (let x = 0; x < this.size; x++) {
                const n = noise.noise2D((this.x * this.size + x) / 50, (this.y * this.size + y) / 50);
                let type = 0;
                if (n < -0.2) type = 4; // water
                else if (n < 0) type = 2; // dirt
                else if (n < 0.2) type = 1; // grass
                else type = 3; // stone
                row.push(type);
            }
            this.tiles.push(row);
        }
    }
}
function drawChunk(chunk) {
    for (let y = 0; y < chunk.size; y++) {
        for (let x = 0; x < chunk.size; x++) {
            const type = chunk.tiles[y][x];
            const def = tileDefinitions[type];
            const variation = def.colorVariation;
            const r = Math.min(255, Math.max(0, parseInt(def.color.slice(1, 3), 16) + (Math.random() - 0.5) * variation.r));
            const g = Math.min(255, Math.max(0, parseInt(def.color.slice(3, 5), 16) + (Math.random() - 0.5) * variation.g));
            const b = Math.min(255, Math.max(0, parseInt(def.color.slice(5, 7), 16) + (Math.random() - 0.5) * variation.b));
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect((chunk.x * chunk.size + x) * tileSize, (chunk.y * chunk.size + y) * tileSize, tileSize, tileSize);
        }
    }
}

const world = new World();
for (let y = -visibleChunks; y <= visibleChunks; y++) {
    for (let x = -visibleChunks; x <= visibleChunks; x++) {
        const chunk = new Chunk(x, y, chunkSize);
        chunk.generatePerlin();
        world.chunks[`${x},${y}`] = chunk;
    }
}

function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let chunkKey in world.chunks) {
        drawChunk(world.chunks[chunkKey]);
    }
    requestAnimationFrame(loop);
}
loop();

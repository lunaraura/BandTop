const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const tileSize = 4;
const chunkSize = 16;
const visibleChunks = 3;

// Panning and input
const pan = { speed: 300 }; // pixels per second when panning
const keys = {};
let selectedTile = 1; // default paint tile
let painting = false;

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const tileDefinitions = {
    0: {name: "empty", color: "#000", colorVariation: {r: 0, g: 0, b: 0}},
    1: {name: "grass", color: "#0f0", colorVariation: {r: 30, g: 30, b: 30}},
    2: {name: "dirt", color: "#964B00", colorVariation: {r: 30, g: 30, b: 30}},
    3: {name: "stone", color: "#888", colorVariation: {r: 20, g: 20, b: 20}},
    4: {name: "water", color: "#00f", colorVariation: {r: 0, g: 0, b: 50}}
}
const specialTileTypes = {
    0: {name: "empty", color: "#000"},
    1: {name: "flower", color: "#f0f", colorVariation: {r: 30, g: 30, b: 30}},
}

class World {
    constructor() {
        this.chunks = {};
    }
    currentChunk(x, y) {
        const chunkX = Math.floor(x / (chunkSize * tileSize));
        const chunkY = Math.floor(y / (chunkSize * tileSize));
        return this.chunks[`${chunkX},${chunkY}`];
    }
    manageVisibleChunks(playerX, playerY) {
        const centerChunkX = Math.floor(playerX / (chunkSize * tileSize));
        const centerChunkY = Math.floor(playerY / (chunkSize * tileSize));
        for (let y = centerChunkY - visibleChunks; y <= centerChunkY + visibleChunks; y++) {
            for (let x = centerChunkX - visibleChunks; x <= centerChunkX + visibleChunks; x++) {
                const key = `${x},${y}`;
                if (!this.chunks[key]) {
                    const chunk = new Chunk(x, y, chunkSize);
                    chunk.generatePerlin();
                    this.chunks[key] = chunk;
                }
            }
        }
        for (let key in this.chunks) {
            const [chunkX, chunkY] = key.split(',').map(Number);
            if (Math.abs(chunkX - centerChunkX) > visibleChunks || Math.abs(chunkY - centerChunkY) > visibleChunks) {
                delete this.chunks[key];
            }
        }
    }
}
class Chunk {
    constructor(x, y, size) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.tiles = [];
    }
    generate() {

    }
    generateSimple() {
        this.tiles = [];
        const allowedTypes = Object.keys(tileDefinitions).map(Number);
        for (let y = 0; y < this.size; y++) {
            const row = [];
            for (let x = 0; x < this.size; x++) {
                const type = allowedTypes[Math.floor(Math.random() * allowedTypes.length)];
                row.push(type);
            }
            this.tiles.push(row);
        }
    }
    generatePerlin() {
        this.tiles = [];
        for (let y = 0; y < this.size; y++) {
            const row = [];
            for (let x = 0; x < this.size; x++) {
                const sampleX = (this.x * this.size + x) / 50;
                const sampleY = (this.y * this.size + y) / 50;
                const n = noise2D(sampleX, sampleY);
                let type = 0;
                if (n < -0.2) type = 4; // water
                else if (n < 0) type = 2; // dirt
                else if (n < 0.2) type = 1; // grass
                else type = 3; // stone
                row.push(type);
            }
            this.tiles.push(row);
        }
    }
}
// Deterministic 2D noise (value in [-1,1]) using a hash/sin trick
function noise2D(x, y) {
    const s = Math.sin(x * 127.1 + y * 311.7) * 43758.5453;
    return (s - Math.floor(s)) * 2 - 1;
}
function drawChunk(chunk) {
    for (let y = 0; y < chunk.size; y++) {
        for (let x = 0; x < chunk.size; x++) {
            const type = chunk.tiles[y][x];
            const def = tileDefinitions[type];
            const variation = def.colorVariation;
            const baseR = parseInt(def.color.slice(1, 3), 16);
            const baseG = parseInt(def.color.slice(3, 5), 16);
            const baseB = parseInt(def.color.slice(5, 7), 16);
            const r = Math.min(255, Math.max(0, baseR + (Math.random() - 0.5) * (variation ? variation.r : 0)));
            const g = Math.min(255, Math.max(0, baseG + (Math.random() - 0.5) * (variation ? variation.g : 0)));
            const b = Math.min(255, Math.max(0, baseB + (Math.random() - 0.5) * (variation ? variation.b : 0)));
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            const worldX = (chunk.x * chunk.size + x) * tileSize;
            const worldY = (chunk.y * chunk.size + y) * tileSize;
            const screenX = worldX - camera.x;
            const screenY = worldY - camera.y;
            // skip tiles off-screen
            if (screenX + tileSize < 0 || screenY + tileSize < 0 || screenX > canvas.width || screenY > canvas.height) continue;
            ctx.fillRect(screenX, screenY, tileSize, tileSize);
        }
    }
}

// Camera object (updated each frame) - start so world origin (0,0) is centered
const camera = { x: -window.innerWidth / 2, y: -window.innerHeight / 2 };

function drawGrid() {
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    // vertical lines
    const startX = - (camera.x % tileSize);
    for (let x = startX; x < canvas.width; x += tileSize) {
        ctx.moveTo(x + 0.5, 0);
        ctx.lineTo(x + 0.5, canvas.height);
    }
    // horizontal lines
    const startY = - (camera.y % tileSize);
    for (let y = startY; y < canvas.height; y += tileSize) {
        ctx.moveTo(0, y + 0.5);
        ctx.lineTo(canvas.width, y + 0.5);
    }
    ctx.stroke();
}

const world = new World();
// seed visible chunks around world origin (camera centered at 0,0)
world.manageVisibleChunks(camera.x + canvas.width / 2, camera.y + canvas.height / 2);

function loop() {
    const now = performance.now();
    if (!loop.last) loop.last = now;
    const dt = (now - loop.last) / 1000;
    loop.last = now;

    // update camera position from keys (WASD / arrows pan the world)
    let dx = 0, dy = 0;
    if (keys['ArrowUp'] || keys['w']) dy -= 1;
    if (keys['ArrowDown'] || keys['s']) dy += 1;
    if (keys['ArrowLeft'] || keys['a']) dx -= 1;
    if (keys['ArrowRight'] || keys['d']) dx += 1;
    if (dx !== 0 || dy !== 0) {
        const len = Math.hypot(dx, dy) || 1;
        camera.x += (dx / len) * pan.speed * dt;
        camera.y += (dy / len) * pan.speed * dt;
    }

    const centerWorldX = camera.x + canvas.width / 2;
    const centerWorldY = camera.y + canvas.height / 2;
    world.manageVisibleChunks(centerWorldX, centerWorldY);

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let chunkKey in world.chunks) {
        drawChunk(world.chunks[chunkKey]);
    }
    drawGrid();

    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(8, 8, 110, 26);
    ctx.fillStyle = '#fff';
    ctx.font = '12px sans-serif';
    ctx.fillText('Selected: ' + (tileDefinitions[selectedTile] ? tileDefinitions[selectedTile].name : selectedTile), 14, 24);

    requestAnimationFrame(loop);
}
loop();

// keyboard controls
// helper to set a tile at world pixel coordinates
function setTileAtWorld(worldX, worldY, type) {
    const tileX = Math.floor(worldX / tileSize);
    const tileY = Math.floor(worldY / tileSize);
    const chunkX = Math.floor(tileX / chunkSize);
    const chunkY = Math.floor(tileY / chunkSize);
    const localX = tileX - chunkX * chunkSize;
    const localY = tileY - chunkY * chunkSize;
    const key = `${chunkX},${chunkY}`;
    let chunk = world.chunks[key];
    if (!chunk) {
        chunk = new Chunk(chunkX, chunkY, chunkSize);
        chunk.generatePerlin();
        world.chunks[key] = chunk;
    }
    if (!chunk.tiles[localY]) return;
    chunk.tiles[localY][localX] = type;
}

function handlePointerEvent(e) {
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    const worldX = camera.x + sx;
    const worldY = camera.y + sy;
    const type = (e.button === 2) ? 0 : selectedTile;
    setTileAtWorld(worldX, worldY, type);
}

canvas.addEventListener('pointerdown', (e) => {
    painting = true;
    canvas.setPointerCapture(e.pointerId);
    handlePointerEvent(e);
});
canvas.addEventListener('pointermove', (e) => {
    if (!painting) return;
    handlePointerEvent(e);
});
canvas.addEventListener('pointerup', (e) => {
    painting = false;
    try { canvas.releasePointerCapture(e.pointerId); } catch (err) {}
});
canvas.addEventListener('contextmenu', (e) => e.preventDefault());

window.addEventListener('keydown', (e) => {
    // number keys to select tile types (1..9)
    if (/^[1-9]$/.test(e.key)) {
        selectedTile = Number(e.key);
        return;
    }
    keys[e.key] = true;
});
window.addEventListener('keyup', (e) => { keys[e.key] = false; });

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext("2d");
const globalSpeed = 10;
const globalCSpeed = 100; //in ticks probably
const solid = "solid";
const liquid = "liquid";
const gas = "gas";
const plasma = "plasma";
let drawing = [];
let entityList = []
let iteration = 0

const composites = {
    stone:       {name: "stone", matter: solid,  tough: 0.30, hard: 0.8, energy: 0.0, elastic: 0.0, heatResist: 0.40, coldResist: 0.35, chemResist: 0.6,
        electroResist: 1.0, density: 0.75},
    crystalline: {name: "crystalline", matter: solid,  tough: 0.15, hard: 0.9, energy: 0.0, elastic: 0.0, heatResist: 0.35, coldResist: 0.30, chemResist: 0.5,
        electroResist: 1.0, density: 0.75},
    metal:       {name: "metal", matter: solid,  tough: 0.80, hard: 0.7, energy: 0.0, elastic: 0.2, heatResist: 0.45, coldResist: 0.50, chemResist: 0.55,
        electroResist: 0.1, density: 0.75},
    //
    organicAnimal:{name: "organicAnimal", matter: solid, tough: 0.60, hard: 0.3, energy: 0.2, elastic: 0.7, heatResist: 0.30, coldResist: 0.25, chemResist: 0.20,
        electroResist: 0.3, density: 0.75},
    organicPlant: {name: "organicPlant", matter: solid, tough: 0.40, hard: 0.5, energy: 0.4, elastic: 0.6, heatResist: 0.25, coldResist: 0.20, chemResist: 0.15,
        electroResist: 0.4, density: 0.75},
    slime:       {name: "slime", matter: solid, tough: 0.50, hard: 0.1, energy: 0.4, elastic: 1.0, heatResist: 0.30, coldResist: 0.30, chemResist: 0.15,
        electroResist: 0.2, density: 0.75},
    //
    water:       {name: "water", matter: liquid, tough: 0.00, hard: 0.0, energy: 0.5, elastic: 1.0, heatResist: 0.8, coldResist: 0.10, chemResist: 0,
        electroResist: 0.1, density: 0.75},
    lava:        {name: "lava", matter: liquid, tough: 0.60, hard: 0.2, energy: 0.7, elastic: 0.3, heatResist: 1.0, coldResist: 0.05, chemResist: 3,
        electroResist: 0.6, density: 0.75},
    gas:         {name: "gas", matter: gas, tough: 0.00, hard: 0.0, energy: 0.8, elastic: 1.0, heatResist: 0.2, coldResist: 0.10, chemResist: 0.3,
        electroResist: 0.6, density: 0.75},
    fire:        {name: "fire", matter: plasma, tough: 0.00, hard: 0.0, energy: 0.9, elastic: 1.0, heatResist: 1.0, coldResist: 0.0, chemResist: 0.9,
        electroResist: 0.8, density: 0.75},
    frost:       {name: "frost", matter: gas, tough: 0.00, hard: 0.1, energy: 1.0, elastic: 0.0, heatResist: 0.0, coldResist: 1.0, chemResist: 0.9,
        electroResist: 0.8, density: 0.75},
    arcane:      {name: "arcane", matter: plasma, tough: 0.00, hard: 0.0, energy: 0.9, elastic: 1.0, heatResist: 1.0, coldResist: 0.0, chemResist: 0.9,
        electroResist: 0.5, density: 0.75},
}
//maybe if u supereffective the inner composite, monster faints ez
const modusEncephalus = { //or not, prob wont be used
    organicBrain: [composites.organicAnimal, composites.organicPlant, composites.slime],
    electroCPU: [composites.stone, composites.crystalline, composites.metal,
        composites.slime, composites.organicAnimal, composites.organicPlant],
    arcane: [composites.stone, composites.crystalline, composites.metal, composites.organicAnimal, composites.organicPlant,
        composites.slime, composites.lava, composites.gas, composites.fire, composites.frost, composites.arcane],
}
const moveType = {
    electric: {matter: plasma, electro: 1.0}, 
    water: {matter: liquid, hard: 0.2, cold: 0.1},
    fire: {matter: plasma, heat: 0.9},
    cold: {matter: gas, cold: 0.9},
    corrode: {matter: liquid, hard: 0.5, chemical: 0.6},
    fumes: {matter: gas, chemical: 0.9},
    smash: {matter: solid, tough: 0.9, hard: 0.1, elastic: 0.2}, 
    slice: {matter: solid, tough: 0.1, hard: 0.9, elastic: 0.0},
    shockwave: {matter: solid, tough: 0.5, hard: 0.1, elastic: 0.5},
    drill: {matter: solid, tough: 0.2, hard: 0.1, elastic: 0.8},
}
const family = {
    canine: {baseIn: {type: composites.organicAnimal, variation: 0.3}, baseOut: {type: composites.organicAnimal, variation: 0.2}, modus: modusEncephalus.organicBrain},
    feline: {baseIn: {type: composites.organicAnimal, variation: 0.05}, baseOut: {type: composites.organicAnimal, variation: 0.1}, modus: modusEncephalus.organicBrain},
    reptile: {baseIn: {type: composites.organicAnimal, variation: 0.05}, baseOut: {type: composites.organicAnimal, variation: 0.1}, modus: modusEncephalus.organicBrain},
    bird: {baseIn: {type: composites.organicAnimal, variation: 0.05}, baseOut: {type: composites.organicAnimal, variation: 0.2}, modus: modusEncephalus.organicBrain},
    bug: {baseIn: {type: composites.organicAnimal, variation: 0.05}, baseOut: {type: composites.organicAnimal, variation: 0.2}, modus: modusEncephalus.organicBrain},
    spectre: {baseIn: {type: composites.gas, variation: 0.0}, baseOut: {type: composites.gas, variation: 0.2}, modus: modusEncephalus.arcane},
    elemental: {baseIn: {type: composites.arcane, variation: 0.0}, baseOut: {type: composites.organicAnimal, variation: 1.0}, modus: modusEncephalus.arcane},
    mecha: {baseIn: {type: composites.metal, variation: 0.1}, baseOut: {type: composites.metal, variation: 0.1}, modus: modusEncephalus.electroCPU},
} 
const species = {
    houseDog: {name: "Dog", family: family.canine, baseSize: 5},
    houseCat: {name: "Cat", family: family.feline, baseSize: 3},
    wolf: {name: "Wolf", family: family.canine, baseSize: 6},
    bird: {name: "Bird", family: family.canine, baseSize: 1},
    mechBird: {name: "Mecha Bird", family: family.bird, baseSize: 15},
}
const speciesInnateVariation = {
    canine: {pAtk:{t: 0.5, r: 10}, eAtk:{t: 0, r: 1}, maxHP: {t: 0.5, r: 20},
        speed: {t: 0, r: 2}, def: {t: 0.5, r: 2}, castSpd: {t: 0.5, r: 1}},
    feline: {pAtk:{t: 0.5, r: 10}, eAtk:{t: 0.5, r: 1}, maxHP: {t: 0.5, r: 15},
        speed: {t: 0.5, r: 5}, def: {t: 0.5, r: 1}, castSpd: {t: 0.5, r: 1}},
    reptile: {pAtk:{t: 0.5, r: 20}, eAtk:{t: 0.5, r: 1}, maxHP: {t: 0.5, r: 10},
        speed: {t: 0.5, r: 1}, def: {t: 0.5, r: 1}, castSpd: {t: 0.5, r: 1}},
    bird: {pAtk:{t: 1, r: 10}, eAtk:{t: 0, r: 10}, maxHP: {t: 1, r: 10},
        speed: {t: 0.5, r: 10}, def: {t: 0.5, r: 1}, castSpd: {t: 0.5, r: 1}},
    bug: {pAtk:{t: 0.5, r: 5}, eAtk:{t: 0.5, r: 1}, maxHP: {t: 1, r: 10},
        speed: {t: 0.5, r: 1}, def: {t: 0.5, r: 1}, castSpd: {t: 0.5, r: 1}},
    spectre: {pAtk:{t: 1, r: 5}, eAtk:{t: 0.5, r: 1}, maxHP: {t: 1, r: 10},
        speed: {t: 0.5, r: 1}, def: {t: 0.5, r: 1}, castSpd: {t: 0.5, r: 1}},
    elemental: {pAtk:{t: 1, r: 5}, eAtk:{t: 0.5, r: 1}, maxHP: {t: 1, r: 10},
        speed: {t: 0.5, r: 1}, def: {t: 0.5, r: 1}, castSpd: {t: 0.5, r: 1}},
}
function makeRNG(seed=123456789){
    let s = seed >>> 0;
    return function rand(){
        s ^= s << 13; s >>>= 0;
        s ^= s >> 17; s >>>= 0;
        s ^= s << 5; s >>>= 0;
        return (s >>> 0) / 0xFFFFFFFF
    }
}

class Entity{
    constructor(species, x, y, extraSize = 0){
        this.x = x;
        this.y = y;

        //
        this.originalStats = null;
        this.size = species.baseSize + extraSize;
        this.HP = null; this.maxHP = null;
        this.pAtk = null; this.eAtk = null;
        this.def = null; this.res = null;
        this.speed = null; this.castSpd = null;
        //
        
        this.species = species.name;
        this.generateEntity(species)
        entityList.push(this)
    }
    generateEntity(species) {
        let seed = makeRNG(Math.round(Math.random() * 100000000));
        let random = seed();

        let thresholdIn = species.family.baseIn.variation;
        let thresholdOut = species.family.baseOut.variation;

        let originalIn = species.family.baseIn.type;
        let originalOut = species.family.baseOut.type;
        let modus = species.family.modus;

        let rolledInner = this.rollCompositeType(originalIn, thresholdIn, random, modus);
        let rolledOuter = this.rollCompositeType(originalOut, thresholdOut, random, composites);
        const familyName = Object.keys(family).find(key => family[key] === species.family);
        const innateVariation = speciesInnateVariation[familyName];
        if (!innateVariation) {
            console.error(`No innate variation found for family: ${familyName}`);
            return null;
        }
        const entitySize = this.size;
        const stats = this.inheritBaseStats(rolledInner, rolledOuter, entitySize);
        const finalStats = this.addInnateStats(stats, innateVariation)
        //for draw
        draw(this.size, finalStats.HP, finalStats.maxHP, {x: this.x, y: this.y})
        //
        this.species = species.name
        this.innerComposite = rolledInner;
        this.outerComposite = rolledOuter;
        this.originalStats = finalStats
        this.setStats(finalStats)
    }
    rollCompositeType(baseComposite, variation, random, compositePool) {
        if (random < variation) {
            const availableComposites = Object.values(compositePool).filter(
                comp => comp.name !== baseComposite.name
            );
            const newComposite =
                availableComposites[Math.floor(Math.random() * availableComposites.length)];

            return { ...newComposite };
        }
        return { ...baseComposite };
    }
    inheritBaseStats(innerComposite, outerComposite, entitySize, globalSpeed = 10) {
        const healthCalc = (comp, size) => (comp.tough + comp.hard + comp.elastic) * size;
        const physAtkCalc = (comp, size) => (comp.hard + comp.tough) * size;
        const energAtkCalc = (comp, size) => comp.energy * size;
        const defenseCalc = (comp, size) => comp.tough * size;
        const resistCalc = (comp, size) => ((comp.heatResist + comp.coldResist + comp.chemResist + comp.electroResist) / 4) * size;

        const maxHP = healthCalc(innerComposite, entitySize) + healthCalc(outerComposite, entitySize);
        const pAtk = physAtkCalc(innerComposite, entitySize) + physAtkCalc(outerComposite, entitySize);
        const eAtk = energAtkCalc(innerComposite, entitySize) + energAtkCalc(outerComposite, entitySize);
        const def = defenseCalc(innerComposite, entitySize) + defenseCalc(outerComposite, entitySize);
        const res = resistCalc(innerComposite, entitySize) + resistCalc(outerComposite, entitySize);
        const speed = globalSpeed / entitySize;
        const castSpd = globalCSpeed * (entitySize/2);
        return {
            maxHP: Math.max(0, maxHP.toFixed(3)),
            pAtk: Math.max(0, pAtk.toFixed(3)),
            eAtk: Math.max(0, eAtk.toFixed(3)),
            def: Math.max(0, def.toFixed(3)),
            res: Math.max(0, res.toFixed(3)),
            speed: Math.max(0.1, speed.toFixed(3)),
            castSpd: Math.max(0.1, castSpd.toFixed(3)),
        };
    }
    addInnateStats(stats, vari){ //should be mostly linear addition
        let add = {
            maxHP: (Math.random() - vari.maxHP.t) * vari.maxHP.r,
            pAtk: (Math.random() - vari.pAtk.t) * vari.pAtk.r,
            eAtk: (Math.random() - vari.eAtk.t) * vari.eAtk.r,
            def: (Math.random() - vari.def.t) * vari.def.r,
            speed: (Math.random() - vari.speed.t) * vari.speed.r,
            castSpd: (Math.random() - vari.castSpd.t) * vari.castSpd.r,
        }
        return {
            maxHP: Math.max(0, (stats.maxHP + add.maxHP).toFixed(3)),
            pAtk: Math.max(0, (stats.pAtk + add.pAtk).toFixed(3)),
            eAtk: Math.max(0, (stats.eAtk + add.eAtk).toFixed(3)),
            def: Math.max(0, (stats.def + add.def).toFixed(3)),
            res: Math.max(0, (stats.res)),
            speed: Math.max(0.1, (stats.speed + add.speed).toFixed(3)),
            castSpd: Math.max(0.1, Math.round(stats.castSpd + add.castSpd)),
        }
    }
    setStats(stat){
        this.maxHP = stat.maxHP; this.HP = stat.maxHP;
        this.pAtk = stat.pAtk; this.eAtk = stat.eAtk;
        this.def = stat.def; this.res = stat.res;
        this.speed = stat.speed; this.castSpd = stat.castSpd;
    }
    aiMove() {
        const safe = this.size * 2;
        let closestEntity = null;
        let closestDistance = Infinity;

        for (let entity of entityList) {
            if (entity === this) continue;
            const realvect = { x: entity.x - this.x, y: entity.y - this.y };
            const dist = Math.hypot(realvect.x, realvect.y);

            if (dist < closestDistance) {
                closestDistance = dist;
                closestEntity = entity;
            }
        }
        if (!closestEntity) return;

        const realvect = { x: closestEntity.x - this.x, y: closestEntity.y - this.y };
        const vect = {
            x: realvect.x - closestEntity.size / 2 - this.size / 2,
            y: realvect.y - closestEntity.size / 2 - this.size / 2,
        };
        const dist = Math.hypot(vect.x, vect.y);
        const dir = { x: vect.x / dist, y: vect.y / dist };

        // Decide action based on distance
        if (dist > safe) {
            // Move closer to the target
            this.x += dir.x * this.speed;
            this.y += dir.y * this.speed;
            // console.log(this.species, "move to", closestEntity.species);
        } else if (dist < safe && dist > this.size) {
            // Attack the target
            this.attack(closestEntity);
            // console.log(this.species, "attack", dist, closestEntity.species);
        } else {
            // Move away from the target
            this.x -= dir.x * this.speed;
            this.y -= dir.y * this.speed;
            // console.log("move away");
        }
    }
    attack(entity){
        //blablabla pretend in range
        //and also tick count cooldown replaced with (atk / 100)
        //if cooldowns come in, this gets to choose between abilities etc
        entity.HP -= this.pAtk / 50;
    }
    checkAlive(){
        if (this.HP <= 0){
            this.setStats(this.originalStats)
            //placeholder spawn
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
        }
    }
    loop(){
        this.aiMove()
        this.checkAlive();
    }
}


let dogEntity = new Entity(species.houseDog, 20, 20, 5);
let catEntity = new Entity(species.houseCat, 80, 50, 5);
let bird = new Entity(species.bird, 90, 90, 5);

function draw(size, HP, name, pos){
    ctx.fillRect(pos.x - size/2, pos.y - size/2, size, size)
    // ctx.fillText(Math.round(maxHP) + "maxHP", pos.x + 5 + size, pos.y + 5);
    ctx.fillText(name, pos.x, pos.y - 10)
    ctx.fillText(Math.round(HP) + "HP", pos.x + 10 + size, pos.y + 15);

}

function gloop(){
    ctx.clearRect(0,0,canvas.width, canvas.height)
    for (let entity of entityList){
        entity.loop();
        draw(entity.size, entity.HP, entity.species, {x: entity.x, y: entity.y})
    }
}
setInterval(gloop, 100)
